/* -*- mode: C;-*- */
%{
/*
   LoMetlogParser.l -- lex source for parsing Robolocust metrics log files

   This file defines various rules for parsing Robolocust metrics log
   files. We don't really need a grammar for that; therefore, we don't
   need yacc/bison; lex alone will do a fine job. That's why this
   "lexical analyzer" is referred to as a "parser." In fact, this lexer
   really is a parser because it isn't concerned with tokenization;
   instead, it simply looks for certain patterns in the input and
   immediately takes appropriate action to parse that input.

   NOTE: This parser is designed specifically for the metlog files spit
   out by the trajectory related experiments concerned with measuring the
   performance of LGMD-based obstacle avoidance algorithms in a local
   navigation task involving a slalom course. It won't work with
   arbitrary metlog files.
*/

// Primary maintainer for this file: mviswana usc edu
// $HeadURL: svn://isvn.usc.edu/software/invt/trunk/saliency/src/Robots/LoBot/metlog/LoMetlogParser.l $
// $Id: LoMetlogParser.l 14285 2010-12-01 17:33:15Z mviswana $

// lobot headers
#include "Robots/LoBot/metlog/LoExperiment.H"
#include "Robots/LoBot/metlog/LoPointTypes.H"
#include "Robots/LoBot/util/LoString.H"

// In the code generated by flex, the yy_get_next_buffer() function
// performs a comparison between a signed and unsigned variable. This
// produces a compiler warning, which results in an error because, by
// default, INVT builds are setup to treat all warnings as errors. Since
// we really can't fix the code generated by flex, we resort to turning
// off this warning so that the .C file generated from this Lex source
// builds without any hassles.
//
// DEVNOTE: On Debian etch, which has GCC 4.1.2, this works fine because,
// apparently, the compiler does not care for the signed-unsigned match
// in yy_get_next_buffer().
//
// On Debian lenny, which comes with GCC 4.3.2, and on Ubuntu 10.04LTS
// (Lucid Lynx), which comes with GCC 4.4.3, the diagnostic pragma is
// supported. Thus, we test for at least version 4.3 of GCC.
//
// This may not work on other systems with other versions of GCC. An
// alternative workaround is not known for this particular problem.
#if __GNUC__ >= 4 && __GNUC_MINOR__ >= 3
#pragma GCC diagnostic ignored "-Wsign-compare"
#endif

// The metlog loader object, which is responsible for loading and parsing
// Robolocust metrics logs, uses this lex-generated scanner for the
// desired parsing functionality. The parsed results are stored in an
// instance of the lobot::Experiment class. The loader object has to
// create the Experiment that will receive the parsing results and pass
// it to this scanner module using flex's extra data mechanism.
//
// By default, flex considers extra data to be a void* that should be
// casted as required. However, we can use this macro to redefine the
// extra data's type so as to avoid unnecessary casting.
#define YY_EXTRA_TYPE lobot::Experiment*

// When no rules match, flex's default action is to echo the input to
// stdout. This can be quite annoying when we would like our program to
// go about its work with minimal chatter.
//
// One way to suppress the echo action is to define a fallback rule at
// the end of the rules section that applies when none of the others
// match and have an empty action. However, for some strange reason,
// this does not always work.
//
// As a workaround, we define the ECHO macro used by flex to be empty.
// This seems to work fine.
#define ECHO

%}

/*
   These states are used by the scanner for extracting robot position and
   speed information from the metlogs.
*/
%x LOMP_GOAL_POSE LOMP_POSE_X LOMP_POSE_Y LOMP_SPEED

/*
   Since this scanner will be used to parse multiple log files in
   parallel, we need it to be reentrant to ensure that it works properly
   in a multithreaded environment.
*/
%option reentrant

/*
   The scanner is used to parse metrics logs stored on disk. It will
   never be used interactively by end users.
*/
%option batch never-interactive

/*
   The lomet program uses another lex-based scanner for tokenizing the
   config file. To ensure this one doesn't clash with that, we change the
   default function prefixes from "yy" to the following.
*/
%option prefix="lomet_parser_"

/*
   Even though lex generates C code, this scanner is actually part of a
   C++ program. Therefore, we might as well have it generate the code in
   a file that the compiler and build system will readily recognize as
   C++. Furthermore, because of the way the INVT automatic dependency
   calculator works, we also need a corresponding header file that we can
   include in the client module's C++ source file to get the final link
   step to work properly.

   DEVNOTE: The build takes place in the saliency root directory.
   Consequently, we must specify the full pathname relative to that
   directory to get flex to send the C source and header files to the
   proper location under the Robolocust root. If we were to use only the
   base file names, e.g., LoMetlogParser.C, the output would end up in
   the saliency root directory and would not be found by the other
   Robolocust modules that depend on this parser.
*/
%option outfile="src/Robots/LoBot/metlog/LoMetlogParser.C"
%option header-file="src/Robots/LoBot/metlog/LoMetlogParser.H"

/*
   Instruct flex to suppress unnecessary functions so that we don't get
   any warnings (which can be show stoppers no thanks to INVT's use of
   -Werror in its build system).
*/
%option noyywrap nounput

/*----------------------------- LEX RULES -----------------------------*/

%%

%{
// Each entry in a Robolocust metrics log begins with a time stamp
// expressed as the number of milliseconds elapsed since the Unix epoch.
// For the most part, we don't care about these time stamps; however, for
// some metlog entries, we do want to record them.
//
// To avoid the hassle of trying to backtrack our way to the start of the
// line on lines that require the time stamps recorded, we simply record
// the time stamp on each line in a temporary, local variable as we
// encounter these stamps. Then, when we come across an entry where we
// require the time stamp, all we need to do is use the above-mentioned
// local variable, which is defined below.
long long int lomp_time_stamp = 0 ;

// This variable keeps track of the proper lobot::Experiment position
// list into which we should insert the next piece of position
// information that we come across in the metlog.
lobot::PointListName lomp_pose_target = lobot::TRAJECTORY ;

// These two variables keep track of the latest position coordinates
// retrieved from the metlog.
int lomp_pose_x = 0, lomp_pose_y = 0 ;
%}

   /*
      This rule "captures" the time stamps that start off all log entries
      in a local variable within the yylex() function. Other rules that
      are interested in the time stamp can simply use the value stored in
      this variable.
   */
^[[:digit:]]+ {
      lomp_time_stamp = lobot::from_string<long long int>(yytext) ;
   }

   /*
      Robolocust's goal behaviour spits out a fairly long metlog entry
      that spans two lines. When we're parsing these lines, we don't
      really care for most of the info they contain save for the time
      stamp and the robot's position within the map.

      The next three rules take care of the details of recording this
      information properly.
   */
"seeking goal" {
      yyextra->start_time(lomp_time_stamp) ;
      BEGIN(LOMP_GOAL_POSE) ;
   }

"reached goal" {
      yyextra->finis_time(lomp_time_stamp) ;
      BEGIN(LOMP_GOAL_POSE) ;
   }

<LOMP_GOAL_POSE>.*\n {
      /*
         Discard everything on the first line of the goal behaviour's
         metlog entry and then enter the LOMP_POSE_X state to read the
         robot's position's x-coordinate.
      */
      lomp_pose_target = lobot::TRAJECTORY ;
      BEGIN(LOMP_POSE_X) ;
   }

   /*
      Rules for extracting the robot position reported by various other
      behaviours.
   */
"tracking pose" {
      lomp_pose_target = lobot::TRAJECTORY ;
      BEGIN(LOMP_POSE_X) ;
   }

"emergency stop" {
      lomp_pose_target = lobot::EMERGENCY_STOP ;
      BEGIN(LOMP_POSE_X) ;
   }

"lgmd_extricate" {
      lomp_pose_target = lobot::LGMD_EXTRICATE ;
      BEGIN(LOMP_POSE_X) ;
   }

"extricate" {
      lomp_pose_target = lobot::EXTRICATE ;
      BEGIN(LOMP_POSE_X) ;
   }

"bump" {
      lomp_pose_target = lobot::BUMP ;
      BEGIN(LOMP_POSE_X) ;
   }

   /*
      When we want to read the robot's x-coordinate within the map, we
      discard everything that doesn't look like a number. Then, after we
      do find a number, we go into the LOMP_POSE_Y state to read the
      y-coordinate.
   */
<LOMP_POSE_X>[-+]?[[:digit:]]+ {
      lomp_pose_x = lobot::from_string<int>(yytext) ;
      BEGIN(LOMP_POSE_Y) ;
   }

<LOMP_POSE_X>. {/* ignore everything that doesn't look like a number */}

   /*
      Just as we did when we read the x-coordinate of the robot's
      position, we ignore everything that doesn't look like a number.
      When we finally do come across a valid number, we read it and then
      pass the x and y coordinates to the output lobot::Experiment
      object. Since the lobot::Experiment object contains several
      different lists of positions, we have to take care that we record
      the most recent position info parsed from the metlog in the
      appropriate list.
   */
<LOMP_POSE_Y>[-+]?[[:digit:]]+ {
      lomp_pose_y = lobot::from_string<int>(yytext) ;
      yyextra->add_point(lomp_pose_target, lomp_pose_x, lomp_pose_y) ;
      BEGIN(INITIAL) ;
   }

<LOMP_POSE_Y>. {/* ignore everything that doesn't look like a number */}

   /*
      The final metlog entry of interest to us is the one that records
      the robot's speed. The next three rules take care of the details of
      extracting this info from the log.
   */
"tracking speed" {
      BEGIN(LOMP_SPEED) ;
   }

<LOMP_SPEED>[-+]?[[:digit:]]+(\.[[:digit:]]*)? {
      yyextra->add_speed(lobot::from_string<float>(yytext)) ;
      BEGIN(INITIAL) ;
   }

<LOMP_SPEED>. {/* ignore everything that doesn't look like a number */}
