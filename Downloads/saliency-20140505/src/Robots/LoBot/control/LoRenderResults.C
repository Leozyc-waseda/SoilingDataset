/**
   \file  Robots/LoBot/control/LoRenderResults.C
   \brief This file defines the non-inline member functions of the
   lobot::RenderResults class.
*/

// //////////////////////////////////////////////////////////////////// //
// The iLab Neuromorphic Vision C++ Toolkit - Copyright (C) 2000-2005   //
// by the University of Southern California (USC) and the iLab at USC.  //
// See http://iLab.usc.edu for information about this project.          //
// //////////////////////////////////////////////////////////////////// //
// Major portions of the iLab Neuromorphic Vision Toolkit are protected //
// under the U.S. patent ``Computation of Intrinsic Perceptual Saliency //
// in Visual Environments, and Applications'' by Christof Koch and      //
// Laurent Itti, California Institute of Technology, 2001 (patent       //
// pending; application number 09/912,225 filed July 23, 2001; see      //
// http://pair.uspto.gov/cgi-bin/final/home.pl for current status).     //
// //////////////////////////////////////////////////////////////////// //
// This file is part of the iLab Neuromorphic Vision C++ Toolkit.       //
//                                                                      //
// The iLab Neuromorphic Vision C++ Toolkit is free software; you can   //
// redistribute it and/or modify it under the terms of the GNU General  //
// Public License as published by the Free Software Foundation; either  //
// version 2 of the License, or (at your option) any later version.     //
//                                                                      //
// The iLab Neuromorphic Vision C++ Toolkit is distributed in the hope  //
// that it will be useful, but WITHOUT ANY WARRANTY; without even the   //
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      //
// PURPOSE.  See the GNU General Public License for more details.       //
//                                                                      //
// You should have received a copy of the GNU General Public License    //
// along with the iLab Neuromorphic Vision C++ Toolkit; if not, write   //
// to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,   //
// Boston, MA 02111-1307 USA.                                           //
// //////////////////////////////////////////////////////////////////// //
//
// Primary maintainer for this file: mviswana usc edu
// $HeadURL: svn://isvn.usc.edu/software/invt/trunk/saliency/src/Robots/LoBot/control/LoRenderResults.C $
// $Id: LoRenderResults.C 14019 2010-09-23 08:35:03Z mviswana $
//

//------------------------------ HEADERS --------------------------------

// lobot headers
#include "Robots/LoBot/control/LoRenderResults.H"
#include "Robots/LoBot/ui/LoMainWindow.H"

#include "Robots/LoBot/LoApp.H"
#include "Robots/LoBot/slam/LoMap.H"
#include "Robots/LoBot/slam/LoOccGrid.H"
#include "Robots/LoBot/slam/LoSlamParams.H"

#include "Robots/LoBot/config/LoConfigHelpers.H"

// DEVNOTE: We must supply the definition of YY_EXTRA_TYPE prior to
// including LoMetlogParser.H, which is generated by flex. Otherwise, the
// generated header will define YY_EXTRA_TYPE as void* and the linker
// will fail to find the lomet_parser_set_extra function, which will end
// up being declared in this module as taking a void* rather than a
// lobot::Experiment* as it actually does.
//
// Moreover, we must include the flex-generated LoMetlogParser.H header
// after LoExperiment.H. Otherwise, the lobot::Experiment class will not
// be properly declared or defined and the compiler really detests that.
#define YY_EXTRA_TYPE lobot::Experiment*
#include "Robots/LoBot/metlog/LoExperiment.H"
#include "Robots/LoBot/metlog/LoMetlogParser.H"

#include "Robots/LoBot/thread/LoPause.H"

#include "Robots/LoBot/misc/LoExcept.H"
#include "Robots/LoBot/misc/LoRegistry.H"
#include "Robots/LoBot/misc/LoTypes.H"
#include "Robots/LoBot/misc/singleton.hh"

#include "Robots/LoBot/util/LoGL.H"
#include "Robots/LoBot/util/LoFile.H"
#include "Robots/LoBot/util/LoMath.H"
#include "Robots/LoBot/util/triple.hh"

// INVT headers
#include "Util/log.H"

// OpenGL headers
#ifdef INVT_HAVE_LIBGLU
#include <GL/glu.h>
#endif

#ifdef INVT_HAVE_LIBGL
#include <GL/gl.h>
#endif

// Boost headers
#include <boost/algorithm/string.hpp>

// Standard C++ headers
#include <fstream>
#include <sstream>
#include <string>

// Standard C headers
#include <stdio.h>

//----------------------------- NAMESPACE -------------------------------

namespace lobot {

//-------------------------- KNOB TWIDDLING -----------------------------

namespace {

// Retrieve settings from goal section of config file
template<typename T>
inline T conf(const std::string& key, const T& default_value)
{
   return get_conf<T>(LOBE_RENDER_RESULTS, key, default_value) ;
}

// Overload for retrieving triples
template<typename T>
inline triple<T, T, T>
conf(const std::string& key, const triple<T, T, T>& default_value)
{
   return get_conf<T>(LOBE_RENDER_RESULTS, key, default_value) ;
}

/// This local class encapsulates various parameters that can be used to
/// tweak different aspects of the render_results behaviour.
class RenderResultsParams : public singleton<RenderResultsParams> {
   /// This setting specifies the name of the directory under which all
   /// of the lobot and lomet programs' metrics logs and results files
   /// are stored. By default, this string is empty. If the
   /// render_results behaviour is active and this setting is not
   /// explicitly provided, the Robolocust application will report an
   /// error but continue to function (although it would not fulfill its
   /// intended purpose).
   std::string m_results_dir ;

   /// This setting specifies a regex pattern for the names of metrics
   /// log and dataset analysis results files. We assume that the lobot
   /// and lomet programs were used to output metrics logs and results
   /// files for different experiments/datasets under different
   /// subdirectories of a root data directory. If this assumption is not
   /// valid, the render_results behaviour cannot and will not work
   /// properly.
   ///
   /// When this behaviour starts up, it will search the data directory
   /// recursively for all files matching the name specified by this
   /// setting. The value of this setting should be a string and it is
   /// interpreted as an extended regular expression (try: man 7 regex).
   /// Thus, all files under the data directory whose names (relative to
   /// the data directory) match the regex specified by this setting will
   /// be included in the list of files to be loaded and visualized.
   ///
   /// After finding the list of files to be visualized, the
   /// render_results behaviour will then proceed to load the first of
   /// these files. You may use the 'n' (next), 'f' (forward), '+' or
   /// space keys to advance to the next file in the list. To visit the
   /// previous file in the list, press 'b' (back) or '-'. When either
   /// end of the list is reached, the behaviour will continue by simply
   /// wrapping around to the other end.
   ///
   /// This behaviour also supports saving the visualizations using the
   /// 's' (screenshot) key. When the 's' key is pressed, the behaviour
   /// will write an image to the same location as the metlog or results
   /// file currently being visualized. In fact, the screenshot's file
   /// name is simply the metlog or results file's name plus an
   /// extension.
   ///
   /// The default extension is ".png". To save the screenshot as a JPEG
   /// file, set the "screen_capture_fmt" option in the "[ui]" section of
   /// the config file to "jpg". Other image formats are also supported;
   /// check the documentation of the screen_capture_fmt option for more
   /// information.
   std::string m_results_file_name ;

   /// This field holds the screenshot image file name extension to be
   /// used. When the user presses the 's' key, a screenshot is saved to
   /// the same location as the results file being visualized with the
   /// same basename as the results file with this extension added.
   std::string m_ss_fmt ;

   /// In addition to the robot's trajectory from start to goal, each
   /// experiment's metrics log or a dataset's results file records the
   /// following lists of points:
   ///     - bump: where the robot bumped into objects
   ///     - stop: where the emergency_stop behaviour was activated
   ///     - extr: where the LRF-based  extricate behaviour was activated
   ///     - lgmd: where the LGMD-based extricate behaviour was activated
   ///
   /// These flags can be used to turn the rendering of each of the above
   /// lists on or off. By default, the render_results behaviour renders
   /// all the lists.
   bool m_bump, m_stop, m_extr, m_lgmd ;

   /// These settings specify colors to use for the different point
   /// lists.
   GLColor m_bump_color, m_stop_color, m_extr_color, m_lgmd_color ;

   /// The render_results behaviour supports a slideshow mode, wherein it
   /// periodically switches to the next metlog or results file in its
   /// list. The behaviour's update_frequency setting controls the rate
   /// at which the slideshow progresses.
   bool m_slideshow ;

   /// This behaviour can visualize the metrics logs for individual
   /// experiments as well as the results file containing the analysis
   /// for an entire dataset. In slideshow mode, when we get to a dataset
   /// results file after a long string of metlogs, we might want to
   /// pause the slideshow in order to be able to study the average-case
   /// behaviour in greater detail.
   ///
   /// This flag allows us to do that. By default, it is off. When it is
   /// turned on and we reach a dataset's results file, the slideshow
   /// will pause. To restart the slideshow, press the 'p' key.
   bool m_pause_on_dataset ;

   /// The number of milliseconds between successive iterations of this
   /// behaviour.
   ///
   /// NOTE: Whereas the update_delay setting for most behaviours is a
   /// crucial parameter that can disrupt proper robot operation, it is
   /// only used to control the slideshow rate for the render_results
   /// behaviour, which is just an offline, visualization task.
   int m_update_delay ;

   /// Private constructor because this is a singleton.
   RenderResultsParams() ;
   friend class singleton<RenderResultsParams> ;

   // Shortcuts just make code line up nicely
   typedef const std::string& str ;
   typedef const GLColor& Color ;

public:
   /// Accessing the various parameters
   //@{
   static str   results_file_name() {return instance().m_results_file_name ;}
   static str   results_dir(){return instance().m_results_dir;}
   static str   ss_fmt()     {return instance().m_ss_fmt     ;}
   static Color stop_color() {return instance().m_stop_color ;}
   static Color extr_color() {return instance().m_extr_color ;}
   static Color lgmd_color() {return instance().m_lgmd_color ;}
   static Color bump_color() {return instance().m_bump_color ;}
   static bool  render_stop()      {return instance().m_stop ;}
   static bool  render_extr()      {return instance().m_extr ;}
   static bool  render_lgmd()      {return instance().m_lgmd ;}
   static bool  render_bump()      {return instance().m_bump ;}
   static bool  slideshow()        {return instance().m_slideshow        ;}
   static bool  pause_on_dataset() {return instance().m_pause_on_dataset ;}
   static int   update_delay()     {return instance().m_update_delay     ;}
   //@}
} ;

// Parameter initialization
RenderResultsParams::RenderResultsParams()
   : m_results_dir(conf<std::string>("results_dir", "")),
     m_results_file_name(conf<std::string>("results_file_name",
        "/(metlog-[[:digit:]]{8}-[[:digit:]]{6}|result)$")),
     m_ss_fmt(std::string(".") +
              ui_conf<std::string>("screen_capture_fmt", "png")),
     m_bump(conf("render_bump_points", true)),
     m_stop(conf("render_stop_points", true)),
     m_extr(conf("render_lrf_extrication_points",  true)),
     m_lgmd(conf("render_lgmd_extrication_points", true)),
     m_bump_color(conf<int>("bump_points_color",
                            make_triple(255, 0, 0))),
     m_stop_color(conf<int>("stop_points_color",
                            make_triple(255, 165, 0))),
     m_extr_color(conf<int>("lrf_extrication_points_color",
                            make_triple(0, 0, 255))),
     m_lgmd_color(conf<int>("lgmd_extrication_points_color",
                            make_triple(105, 139, 105))),
     m_slideshow(conf("slideshow", false)),
     m_pause_on_dataset(conf("pause_on_dataset", false)),
     m_update_delay(clamp(conf("update_delay", 2500), 500, 60000))
{
   boost::trim(m_results_file_name) ;
}

// Convenient shortcut
typedef RenderResultsParams Params ;

} // end of local anonymous namespace encapsulating above helpers

//-------------------------- INITIALIZATION -----------------------------

RenderResults::RenderResults()
   : base(Params::update_delay(), LOBE_RENDER_RESULTS),
     m_traj(300), m_stop(75), m_extr(25), m_lgmd(50), m_bump(5),
     m_results_file_being_visualized(false)
{
   start(LOBE_RENDER_RESULTS) ;
}

void RenderResults::pre_run()
{
   Map* map = App::map() ;
   if (! map)
      throw behavior_error(MAPPING_DISABLED) ;

   const std::string map_file = SlamParams::map_file() ;
   if (map_file.empty())
      throw behavior_error(MAPPING_DISABLED) ;
   map->update(OccGrid(map_file)) ;
   map->add_hook(RenderHook(render_results,
                            reinterpret_cast<unsigned long>(this))) ;

   std::string goal_conf = get_conf<std::string>(LOBE_GOAL, "goals", "") ;
   if (goal_conf.empty())
      throw behavior_error(NO_GOALS) ;
   std::istringstream goal(goal_conf) ;
   goal >> m_goal ;

   const std::string& results_dir = Params::results_dir() ;
   const std::string& results_file_name = Params::results_file_name() ;
   if (results_dir.empty() || results_file_name.empty())
      throw behavior_error(BAD_RESULTS_SPECS) ;
   m_results_files = find_file(results_dir, results_file_name) ;
   m_results = m_results_files.end() - 1 ;
   next() ;
}

void RenderResults::load(const std::string& file_name)
{
   m_results_file_being_visualized = false ;
   clear_point_lists() ;
   load_metlog(file_name) ;
   if (m_traj.empty()) {    // maybe not a metlog; see if it's a results file
      clear_point_lists() ; // just in case other point lists got some gunk
      load_results(file_name) ;
      m_results_file_being_visualized = true ;
   }

   const char* s = file_name.c_str() ;
   if (m_traj.empty()) // 2nd time failure ==> neither metlog nor results file
      LERROR("%s: not a metlog nor a results file!", s) ;
   else
      LERROR("loaded %s", s) ;
}

void RenderResults::load_metlog(const std::string& file_name)
{
   FILE* file = fopen(file_name.c_str(), "r") ;
   if (! file)
      return ;

   Experiment* experiment = Experiment::create(file_name) ;

   yyscan_t parser ;
   lomet_parser_lex_init(&parser) ;
   lomet_parser_set_extra(experiment, parser) ;
   lomet_parser_set_in(file, parser) ;
   lomet_parser_lex(parser) ;
   lomet_parser_lex_destroy(parser) ;
   fclose(file) ;

   m_traj = experiment->point_list(TRAJECTORY) ;
   m_stop = experiment->point_list(EMERGENCY_STOP) ;
   m_extr = experiment->point_list(EXTRICATE) ;
   m_lgmd = experiment->point_list(LGMD_EXTRICATE) ;
   m_bump = experiment->point_list(BUMP) ;

   delete experiment ;
}

void RenderResults::load_results(const std::string& file_name)
{
   std::ifstream file(file_name.c_str()) ;
   for(;;)
   {
      std::string line ;
      std::getline(file, line) ;
      if (! file)
         break ;

      std::istringstream point_spec(line) ;
      std::string point_type ; int x, y ;
      point_spec >> point_type >> x >> y ;
      if (point_type == "trajectory")
         m_traj.add(x, y) ;
      else if (point_type == "emergency_stop")
         m_stop.add(x, y) ;
      else if (point_type == "extricate")
         m_extr.add(x, y) ;
      else if (point_type == "lgmd_extricate")
         m_lgmd.add(x, y) ;
      else if (point_type == "bump")
         m_bump.add(x, y) ;
   }
}

//---------------------- THE BEHAVIOUR'S ACTION -------------------------

void RenderResults::action()
{
   if (Params::slideshow()) {
      next() ;
      if (Params::pause_on_dataset() && m_results_file_being_visualized)
         Pause::toggle() ;
   }
}

void RenderResults::keypress(unsigned char key)
{
   switch (key)
   {
      case 'n': // next
      case 'N': // next
      case 'f': // forward
      case 'F': // forward
      case '+':
      case ' ':
         next() ;
         break ;
      case 'b': // back
      case 'B': // back
      case '-':
         prev() ;
         break ;
      case 's': // screenshot
      case 'S': // screenshot
         {
            std::string file_name = curr() + Params::ss_fmt() ;
            if (exists(file_name))
               LERROR("%s: already exists; will not overwrite",
                      file_name.c_str()) ;
            else
               MainWindow::instance().save_screenshot(file_name) ;
         }
         break ;
   }
}

void RenderResults::prev()
{
   viz_lock() ;
      if (m_results == m_results_files.begin())
         m_results = m_results_files.end() ;
      --m_results ;
      load(*m_results) ;
   viz_unlock() ;
}

void RenderResults::next()
{
   viz_lock() ;
      ++m_results ;
      if (m_results == m_results_files.end())
         m_results = m_results_files.begin() ;
      load(*m_results) ;
   viz_unlock() ;
}

std::string RenderResults::curr()
{
   viz_lock() ;
      std::string results_file_name = *m_results ;
   viz_unlock() ;
   return results_file_name ;
}

//--------------------------- VISUALIZATION -----------------------------

#ifdef INVT_HAVE_LIBGL

// Quick helper to "emit" GL vertex coordinates from an mPoint.
//
// NOTE: Since the map coordinate system is rotated ccw, we need to swap
// the x and y coordinates.
static void mpoint_to_vertex(const mPoint& p)
{
   glVertex2i(p.second, p.first) ;
}

// Helper function to render a point list
static void
render_points(const PointList& L, const GLColor& color)
{
   glPushAttrib(GL_POINT_BIT | GL_CURRENT_BIT) ;
   glPointSize(5) ;
   glColor3fv(color.rgb()) ;
   glBegin(GL_POINTS) ;
      std::for_each(L.begin(), L.end(), mpoint_to_vertex) ;
   glEnd() ;
   glPopAttrib() ;
}

// This function renders the different point lists read from the results
// file onto the map.
void RenderResults::render_results(unsigned long client_data)
{
   const RenderResults* me = reinterpret_cast<RenderResults*>(client_data) ;

   // Setup 2D "view volume" to match real/physical coordinate system
   // except that the whole thing is rotated 90 degrees ccw so that our
   // notion of "up" matches that of the robot's.
   float L, R, B, T ; // map extents
   SlamParams::map_extents(&L, &R, &B, &T) ;
   me->setup_view_volume(T, B, L, R) ;

   // Now we're ready to draw the goal box and the various point lists...
   me->render_goal() ;
   me->render_traj() ;
   if (Params::render_stop())
      render_points(me->m_stop, Params::stop_color()) ;
   if (Params::render_extr())
      render_points(me->m_extr, Params::extr_color()) ;
   if (Params::render_lgmd())
      render_points(me->m_lgmd, Params::lgmd_color()) ;
   if (Params::render_bump())
      render_points(me->m_bump, Params::bump_color()) ;

   // Reset GL transformations so next drawable won't get screwed
   me->restore_view_volume() ;
}

// Helper function to draw a dashed box signifying the robot's goal
// within the slalom course.
void RenderResults::render_goal() const
{
   glPushAttrib(GL_LINE_BIT) ;
   glEnable(GL_LINE_STIPPLE) ;
   glLineStipple(1, 0xCCCC) ;
   glColor3f(1, 0, 0) ;
   glBegin(GL_LINE_LOOP) ;
      glVertex2f(m_goal.top,    m_goal.left) ;
      glVertex2f(m_goal.bottom, m_goal.left) ;
      glVertex2f(m_goal.bottom, m_goal.right);
      glVertex2f(m_goal.top,    m_goal.right);
   glEnd() ;
   glPopAttrib() ;
}

// Helper function to render the robot's trajectory from start to goal
void RenderResults::render_traj() const
{
   glColor3f(0, 0, 0) ;
   glBegin(GL_LINE_STRIP) ;
      std::for_each(m_traj.begin(), m_traj.end(), mpoint_to_vertex) ;
   glEnd() ;
}

#endif

//----------------------------- CLEAN-UP --------------------------------

void RenderResults::clear_point_lists()
{
   m_traj.clear() ;
   m_stop.clear() ;
   m_extr.clear() ;
   m_lgmd.clear() ;
   m_bump.clear() ;
}

RenderResults::~RenderResults(){}

//-----------------------------------------------------------------------

} // end of namespace encapsulating this file's definitions

/* So things look consistent in everyone's emacs... */
/* Local Variables: */
/* indent-tabs-mode: nil */
/* End: */
