#
# lobot.conf -- sample configuration file for the Robolocust programs
#
# This file serves as a reference for the different settings that can be
# tweaked for different parts of the Robolocust programs. It is not
# meant to be edited and used on a regular basis as it is checked into
# the svn repository and we wouldn't want that file to be constantly
# updated (e.g., after some experimental knob twiddling).
#
# To play around with various settings, it would be better to copy this
# file to ~/.lobotrc and edit that instead.
#
# The syntax of this file closely matches that of INI files often found
# on the Windows platform. Briefly, here are the sytax rules:
#
#     1. Blank lines and comments are ignored.
#
#     2. Only single-line comments are supported.
#
#     3. Comments are started by a '#' or ';' character.
#
#     4. Comments must appear on lines by themselves (i.e., config lines
#        cannot have comments in them).
#
#     5. Config lines can be either section names or key-value
#        assignments.
#
#     6. Section names must start with a letter and may be
#        followed by letters, numbers or the underscore character.
#
#     7. Section names have to be enclosed in square brackets, i.e., '['
#        and ']'.
#
#     8. The key name in a key-value assignment follow the
#        same rules as section names (except that they should not be
#        enclosed in square brackets).
#
#     9. The key name must be followed by an equals sign (which may be
#        surrounded by optional whitespace).
#
#    10. The value must follow the equals sign in a key-value assignment
#        statement.
#
#    11. All tokens following the equals sign (disregarding optional
#        trailing whitespace after the equals sign) comprise the value
#        portion of the key-value statement.
#
#    12. Long key-value statements may be broken up across multiple
#        lines and continued from one line to the next by ending each
#        line with a '\' character. Note that the '\' must be the last
#        character on the line, i.e., it should be immediately followed
#        by a newline and no other trailing whitespace should appear
#        between the '\' and the newline.
#
#        All initial whitespace on the following line will be discarded.
#        Thus, to break up a really long string across multiple lines,
#        don't have any whitespace between the '\' at the end of lines
#        and the immediately preceding character. However, to ensure
#        that tokens on the following lines are considered separate, put
#        some intervening whitespace between the '\' and the previous
#        character.
#
#        The '\' line continuation characters themselves are not part of
#        the value portion of key-value statements.
#
#    13. The value portion of a key-value statement is taken verbatim,
#        i.e., there is no notion of quoting strings and/or escape
#        sequences; the whitespace following the equals sign is ignored
#        and then all characters up to the end of the line are taken as
#        the value corresponding to the specified key.
#
# Simplifying the above legalese: to get things right, just follow the
# pattern laid out in this file. Straying from the above rules and the
# syntax illustrated in this file will probably lead to errors (usually
# of the worst kind, i.e., silent assumptions of weird intent). The code
# that parses this file is mostly just a quick-and-dirty hack and has
# not been tested extensively to iron out all possible bugs. So try not
# to push the envelope here; the basic config file syntax rules are more
# than adequate for most purposes.
#
##########################################################################
#                                                                        #
#     WARNING!     WARNING!     WARNING!     WARNING!     WARNING!       #
#                                                                        #
# Furthermore, do not assume that there is extensive range checking,     #
# validation and other sanity checks on the values/settings specified in #
# here. Thus, for example, if a setting needs to be a number between     #
# zero and one, supply a number between zero and one. Otherwise, expect  #
# Bad Things to happen!                                                  #
#                                                                        #
##########################################################################
#

# Primary maintainer for this file: mviswana usc edu
# $HeadURL: svn://isvn.usc.edu/software/invt/trunk/saliency/src/Robots/LoBot/config/lobot.conf $
# $Id: lobot.conf 14305 2010-12-08 21:17:33Z mviswana $

#--------------------------- GLOBAL SETTINGS ----------------------------

# Robolocust supports several different models of the locust's LGMD.
# This setting specifies which of these LGMD implementations should be
# used. Further settings related to the chosen model usually go in an
# identically named section. Thus, for example, the Stafford model
# settings will be in the [stafford] section; settings specific to the
# Gabbiani model will be in the [gabbiani] section; so on and so forth.
#
# The full list of supported locust models (if somehow not already
# listed here) can be found in LoRegistry.H's "LOCUST MODEL NAMES"
# section. These names are best left all lowercase.
locust_model = stafford
locust_model = gabbiani

# Locust models can get their inputs from video sources (FireWire
# cameras or MPEG files), the laser range finder or directly from live
# locusts connected to the robot via some sort of rig. This setting
# specifies what input source should be used.
#
# NOTE: Not all LGMD models support all input sources. For example, the
# raw LGMD model only works with live locusts. The Gabbiani model OTOH
# can work with video or laser. So on and so forth.
locust_input = video
locust_input = laser
#locust_input = direct

# Robolocust's robot controller is a behaviour-based system. This
# setting allows us to tweak which behaviours we want running.
#
# NOTE: This can be a fairly dangerous setting to fool around with. For
# example, turning off a really crucial behaviour like emergency_stop
# can have disastrous results. Nonetheless, this configuration is
# exposed to end-users in order to provide a convenient means of
# changing high-level aspects of the robot's actions or trying different
# control algorithms, etc.
#
# NOTE 2: To figure out what a behaviour does, you will have to look up
# its source. All behaviours are coded in the control directory. Thus,
# for example, the details of the forward behaviour can be found in
# control/LoForward.[CH]; similarly, the details of laser_avoid are in
# control/LoLaserAvoid.[CH] and those of emergency_stop in
# control/LoEmergencyStop.[CH]; so on and so forth.
behaviors = forward emergency_stop extricate open_path

#########################################################################
# A NOTE ON BEHAVIOUR PRIORITIES
# ------------------------------
# Each behaviour must be assigned a priority. The exact values of these
# priorities don't really matter; it is their relative values that are
# important. Nonetheless, it is probably a good idea to keep these
# values in the range of one to ten.
#
# NOTE: Robolocust's controller contains two DAMN arbiters, one to
# control the robot's steering and another to control its speed. Turn
# behaviours should all be assigned an appropriate value for
# turn_priority. Likewise, speed behaviours should be assigned an
# appropriate speed_priority. Behaviours that control both steering and
# speed must have proper values for both the turn_priority and
# speed_priority settings.
#########################################################################

# As mentioned above, the Robolocust controller is a multithreaded
# behaviour-based system. The main thread is responsible for performing
# sensorimotor updates while the other threads (i.e., the behaviours)
# only read the current states of the sensorimotor systems.
#
# This global setting specifies the number of milliseconds between
# successive iterations of the main thread's update loop.
#
# WARNING: The ability to change the main loop's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 100

# At times, it can be useful to have the Robolocust application come up
# but not actually start until we explicitly give it the go-ahead. For
# example, if we want to setup a screen capture before the robot starts
# doing its thing, then we would want to have the controller come online
# but wait until we are ready before performing any control actions.
#
# This flag can be used to start the Robolocust controller in a paused
# state. By default, it is off.
#
# NOTE: At present, only the UI can trigger pause/resume actions.
# Pressing the 'p' key toggles the application's pause state. If this
# flag is turned on but the UI is configured to be off, then this
# setting won't take effect, i.e., the application will start
# immediately.
#start_paused = yes

#------------------------ TURN ARBITER SETTINGS -------------------------

# The Robolocust controller is a behaviour-based system. Centralized
# DAMN arbiters are used to coordinate access to the robot's motors.
# Each behaviour votes on the actions it wants to execute and the DAMN
# arbiter tallies votes and issues the motor commands.
#
# Robolocust uses three DAMN arbiters, two for controlling the robot's
# steering and another for regulating its driving speed. This section
# specifies settings for the steering related turn arbiter, which is
# responsible for issuing "vector-style" turn commands that veer the
# robot in different directions as it moves (like a car).
[turn_arbiter]

# The turn arbiter maintains a set of turn directions in which it can
# command the motors to go. These directions are specified with a max
# value and a step value. For example, max and step values of 30 and 10
# would indicate that the robot can be commanded to turn in the
# directions corresponding to -30, -20, -10, 0, 10, 20 and 30 degrees.
turn_max  = 24
turn_step = 3

# The turn arbiter tallies all the votes by applying a weighted sum
# procedure (where the weights are the behaviour priorities). It then
# smooths the resulting weighted sum by applying a Gaussian to adjacent
# vote values. The following parameter specifies the size of the
# smoothing window, i.e., it specifies how many neighbouring vote values
# should be considered while smoothing each one.
smoothing_window_width = 5

# This parameter specifies the standard deviation to use for the
# Gaussian smoothing mentioned above. Since the Gaussian operates in
# turn command space, this standard deviation is in degrees.
smoothing_sigma = 1.5

# The number of milliseconds between successive iterations of this
# arbiter.
#
# WARNING: The ability to change an arbiter's update frequency is a very
# powerful feature whose misuse or abuse can wreak havoc! Be sure to use
# reasonable values for this setting.
update_delay = 500

# Arbiters may provide support for visualizing what's going on under the
# hood. However, this support must be turned on explicitly. Otherwise,
# nothing will be visualized.
visualization = on

# The location and size (within the Robolocust main window) of the turn
# arbiter's visualization.
geometry = 480 420 140 140

#------------------------ SPIN ARBITER SETTINGS -------------------------

# As mentioned earlier, the Robolocust controller is a behaviour-based
# system. Centralized DAMN arbiters are used to coordinate access to the
# robot's motors. Each behaviour votes on the actions it wants to
# execute and the DAMN arbiter tallies votes and issues the motor
# commands.
#
# Robolocust uses three DAMN arbiters, two for controlling the robot's
# steering and another for regulating its driving speed. This section
# specifies settings for the steering related spin arbiter, which is
# responsible for issuing in-place turn commands that stop the robot and
# spin it (for differentially steered robots).
[spin_arbiter]

# The number of milliseconds between successive iterations of this
# arbiter.
#
# WARNING: The ability to change an arbiter's update frequency is a very
# powerful feature whose misuse or abuse can wreak havoc! Be sure to use
# reasonable values for this setting.
update_delay = 500

# NOTE: The spin arbiter does not provide any support for visualization.

#----------------------- SPEED ARBITER SETTINGS -------------------------

# As mentioned earlier, the Robolocust controller is a behaviour-based
# system. Centralized DAMN arbiters are used to coordinate access to the
# robot's motors. Each behaviour votes on the actions it wants to
# execute and the DAMN arbiter tallies votes and issues the motor
# commands.
#
# Robolocust uses three DAMN arbiters, two for controlling the robot's
# steering and another for regulating its driving speed. This section
# specifies settings for the speed arbiter.
[speed_arbiter]

# The number of milliseconds between successive iterations of this
# arbiter.
#
# WARNING: The ability to change an arbiter's update frequency is a very
# powerful feature whose misuse or abuse can wreak havoc! Be sure to use
# reasonable values for this setting.
update_delay = 500

# NOTE: The speed arbiter does not provide any support for
# visualization. But then, there really is nothing much to visualize
# here. It simply finds the minimum speed or PWM value amongst all the
# current votes and issues a drive command for that.

#------------------------ DANGER ZONE SETTINGS --------------------------

# This section specifies the settings for the robot's danger zone. These
# settings are used by the emergency stop, extricate and other
# behaviours.
[danger_zone]

# Robolocust's danger zone mechanism works by dividing the laser range
# finder's FOV into several angular blocks.
#
# The following setting specifies the extents of the above-mentioned
# angular blocks. It should be a sorted list of numbers corresponding to
# the supported measurement directions of the laser range finder. Here
# is an example:
#     angular_blocks = -140 -90 -60 60 90 141
#
# The above example would divide the LRF's FOV into the following
# blocks: [-140, -91], [-90, -61] [-60, 59] [60, 89] [90, 141].
#
# Remember that negative angles correspond to the right of the LRF,
# positive ones are for the left and zero degrees is for straight ahead.
angular_blocks = -140 -90 -60 -30 30 60 90 141

# Each range specified by the angular_blocks setting above has its own
# distance
# and threshold setting. A block's distance setting specifies the
# minimum distance between the robot and obstacles in that block.
# The threshold settings specifies the minimum number of LRF distance
# measurements that must be less than its distance setting for the block
# to be actually considered as having an obstacle in it.
#
# The following two settings specify the per-block danger zones and
# thresholds. They should be lists of numbers; the size of the list
# should be one less than the size of the angular_blocks list. For
# example, if angular_blocks = -90 -45 45 90, we have three ranges,
# viz., [-90 -46], [-45 44] and [45 90]. Therefore, the danger_zones and
# thresholds settings should be lists of 3 numbers.
danger_zones = 175 200 225 250 225 200 175
thresholds   =  30  15  10  10  10  15  30

#--------------- MONITOR DANGER ZONE BEHAVIOUR SETTINGS -----------------

# This section specifies the settings for the monitor_danger_zone
# behaviour, which is responsible for seeing if the robot's danger zone
# has been penetrated and then taking some user-defined action in case
# autonomous operation fails to rectify the situation.
[monitor_danger_zone]

# Once the robot's danger zone has been penetrated, the
# monitor_danger_zone behaviour will start an internal stopwatch ticking
# and wait for it to reach at least the amount specified by this setting
# before actually taking any action.
# 
# This setting should be a time delay specified in milliseconds.
duration = 2500

# By default, the monitor_danger_zone behaviour will wait for the robot
# to come to a full stop before considering any action. Thus, if the
# danger zone has been penetrated but the robot is still moving (for
# example, an extricate behaviour is getting the robot unstuck), then
# monitor_danger_zone will not interfere.
# 
# However, by turning this flag off, we can have this behaviour ignore
# the robot's current state of motion so that it takes action whenever
# the danger zone has been penetrated for at least the duration
# specified by the previous setting regardless of whether the robot is
# moving or not.
#wait_for_stop = no

# This setting specifies the action to take when the robot's danger zone
# has been penetrated. The following actions are supported:
# 
#    - Spin, i.e., turn the robot in-place, by some random amount.
#      This is the default action.
# 
#    - Pause the robot and wait for the user to take appropriate action,
#      e.g., remote control to get the robot out of the danger zone.
# 
#      NOTE: The pause action will require the user to explicitly
#      restart the robot's controller, i.e., unpause it by pressing the
#      'p' key. This also requires that the UI not be disabled.
# 
#    - Quit the Robolocust controller application. This can be useful,
#      for instance, when we are running experiments that require us to
#      simply drive the robot up to a wall and then stop and start over.
action = spin

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1000

#------------------------- COUNTDOWN SETTINGS ---------------------------

# This behaviour that keeps track of how much time has elapsed since the
# robot started running. When this time exceeds some preconfigured
# duration, the behaviour will quit the high-level controller
# application.
#
# NOTE: This behaviour does not vote for any motor actions. Nor does it
# perform any visualization. Also, the stop watch will continue to count
# down even if the robot is paused!
[countdown]

# This setting specifies the number of seconds for the countdown. If the
# countdown behaviour is enabled and this setting not specified, it will
# default to 10800 (i.e., 3 hours). The minimum acceptable duration is 5
# seconds; the max is 86400 seconds (24 hours).
duration = 1200

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1000

#--------------------- FORWARD BEHAVIOUR SETTINGS -----------------------

# This section specifies various setings related to the forward driving
# behaviour.
[forward]

# The forward behaviour always attempts to drive the robot forward at
# the specified cruising speed (expressed in m/s).
cruising_speed = 0.3

# In case the robot is configured to ignore its noisy and often useless
# RPM sensor, the forward behaviour will have to work in terms of PWM
# values rather than m/s speed commands.
cruising_pwm = 30

# Instead of driving at a fixed (cruising) speed, the forward driving
# behaviour can be configured to regulate the robot's speed based on the
# distance to the closest obstacle. This flag turns on adaptive driving
# mode.
adaptive_mode = yes

# In adaptive mode, the behaviour will consider the distance readings in
# the angular range specified by this setting.
fov = -60 60

# Adaptive mode works by adjusting the robot's speed according to the
# minimum distance reading in the FOV specified by the above setting.
# However, the behaviour does not consider the "raw" distance readings;
# rather it averages the distance readings in a small block about each
# angle it considers, starting at the FOV's minimum and going up to the
# FOV maximum in steps specified by this setting.
# 
# For example, if the FOV is [-30, 30] and the averaging block is 10,
# the forward behaviour will look at the average distances in the
# following blocks: [-35, -25], [-25, -15], [-5, -15], [-5, 5], [5, 15],
# [15, 25] and [25, 35].
averaging_block = 10

# Once the minimum distance reading has been found, adaptive mode will
# compute a corresponding speed using a simple linear interpolation
# using the minimum distance reading, the distance range setting (see
# below) and the speed range (this setting's value).
speed_range = 0.1 0.5

# Since all speed votes are required to work in terms of both PWM values
# and m/s speeds, we also need a PWM range so that adaptive mode can
# compute an appropriate PWM value using the same linear interpolation
# described above.
pwm_range = 25 100

# As mentioned above, to "convert" LRF distance readings into
# corresponding speed values, we use a linear interpolation that
# involves the minimum distance reading, the distance range (this
# setting) and the speed range (defined above).
distance_range = 250 2500

# Forward driving is a very low priority behaviour
turn_priority  = 1
speed_priority = 1

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1000

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 0 140 140

#----------------------- EMERGENCY STOP SETTINGS ------------------------

# This section specifies settings for the emergency stop behaviour.
[emergency_stop]

# Emergency stop is a very high priority behaviour. Since it only
# affects the robot's speed and not its heading, we only need to specify
# its speed priority.
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 75

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 140 140 140

#-------------------- EXTRICATE BEHAVIOUR SETTINGS ----------------------

# This section specifies settings for the extricate behaviour, which is
# responsible for unsticking the robot after the emergency stop
# behaviour has brought it to a grinding halt.
[extricate]

# Users may specify what speed they would like the extrication to
# occur.
# 
# CAUTION: It would be unwise to make this speed too high.
extricate_speed = 0.15

# In case the RPM sensor is configured to be bypassed, we will need to
# specify the extricate "speed" in terms of PWM values as well.
#
# NOTE: All speed related behaviours should specify both a speed in m/s
# and a PWM value.
#
# CAUTION: For the extricate behaviour, it would be unwise to make the
# extrication PWM too high.
extricate_pwm = 30

# When lobot is running the LGMD-based avoidance behaviours, it can come
# to a complete halt due to the emergency stop behaviour and then not
# restart because the lack of motion will result in the LGMD spikes
# becoming dormant. To work around this problem, we can run the
# LRF-based extricate (i.e., this) behaviour in addition to the
# LGMD-based extricate behaviours to restart the robot and, thereby,
# reinitiate spiking activity.
# 
# However, when run to fulfill the function described above, it would be
# best to reduce the frequency at which this behaviour runs.
# Furthermore, we would also want this behaviour to only perform its
# extrication actions if the robot is actually stopped.
# 
# The following setting is a flag that indicates whether or not this
# behaviour should operate in "restart mode" as described above. By
# default, it is off, i.e., we assume this behaviour is the only active
# extricate behaviour and that it should perform extrication whenever
# the danger zone is penetrated, regardless of the robot's current
# motion state.
restart_mode = no

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the extricate behaviour also supports
# spin-style steering, i.e., momentarily stopping the robot and then
# turning it cw/ccw in-place. This flag turns on spin-style steering. By
# default, the behaviour uses the normal car-like steering mode.
#spin_style_steering = yes

# The extricate behaviour controls both speed and heading. Since it
# needs to kick in after the emergency stop behaviour and be able to
# override that behaviour's instinct to halt the robot, the extricate
# behaviour's priorities need to be higher than or at least equal to
# that of emergency stop.
turn_priority  = 10
spin_priority  = 10
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 75

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 280 140 140

#-------------- LGMD EXTRICATE SIMPLE BEHAVIOUR SETTINGS ----------------

# This section specifies settings for the simple LGMD-based extricate
# behaviour. This behaviour monitors all the LGMD spike trains and spins
# the robot to have it face the direction corresponding to minimal
# spiking activity.
[lgmd_extricate_sim]

# If this extricate behaviour were to spin the robot in each and every
# iteration, it might make the robot zigzag about excessively.
# Therefore, we have the behaviour check the total range of LGMD spike
# rates, i.e., max - min, and act only when this range crosses a
# threshold, i.e., when the range of spiking activity has a significant
# differential in it. If the range is lower than the above-mentioned
# threshold, it means all the locusts are experiencing a similar level
# of spiking and so extrication would simply result in erratic, noisy
# behaviour.
#
# This setting specifies the minimum range across all the LGMD readings
# that we expect to see before the simple, reactive LGMD-based
# extrication will kick in. It should be a positive floating point
# number. Its units are Hertz.
threshold = 50

# Once the above range threshold has been crossed, the behaviour can
# simply spin the robot towards the direction corresponding to minimal
# activity. However, there might be several readings that are the same
# or reasonably close to the minimum. In this situation, we would like
# to spin the robot by the least amount.
#
# The following setting specifies the maximum spike rate starting at the
# minimum that we consider "reasonably low." This extricate behaviour
# then looks at all the "reasonably low" LGMD readings and chooses the
# one that will result in the minimum amount of spin.
#
# The value of this setting should be a floating point number expressed
# in Hertz.
window = 25

# Users may specify what speed they would like the extrication to
# occur.
# 
# CAUTION: It would be unwise to make this speed too high.
extricate_speed = 0.15

# In case the RPM sensor is configured to be bypassed, we will need to
# specify the extricate "speed" in terms of PWM values as well.
#
# NOTE: All speed related behaviours should specify both a speed in m/s
# and a PWM value.
#
# CAUTION: For the extricate behaviour, it would be unwise to make the
# extrication PWM too high.
extricate_pwm = 30

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the lgmd_extricate_emd behaviour also
# supports spin-style steering, i.e., momentarily stopping the robot and
# then turning it cw/ccw in-place. This flag turns on spin-style
# steering. By default, the behaviour uses the normal car-like steering
# mode.
#spin_style_steering = yes

# All extricate behaviours control both speed and heading.
#
# Additionally, since this behaviour can be configured to use in-place
# turning for steering control, we need to specify an appropriate
# priority for the spin arbiter as well.
turn_priority  = 10
spin_priority  = 10
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1000

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 280 140 140

#---------------- LGMD EMD EXTRICATE BEHAVIOUR SETTINGS -----------------

# This section specifies settings for the LGMD-based EMD version of the
# extricate behaviour, which works by pumping the LGMD spike rates into
# an array of elementary motion detectors.
[lgmd_extricate_emd]

# This behaviour's extrication commands will kick in only when the
# magnitude of the spiking vector computed by the EMD array exceeds the
# threshold specified by this setting.
#
# It is a unitless number whose value should be set empirically. This
# behaviour's visualization prints the current values of the EMD
# vector's magnitude. So a good strategy would be to observe those
# values and set this threshold based on those observations.
threshold = 1000

# Users may specify what speed they would like the extrication to
# occur.
# 
# CAUTION: It would be unwise to make this speed too high.
extricate_speed = 0.15

# In case the RPM sensor is configured to be bypassed, we will need to
# specify the extricate "speed" in terms of PWM values as well.
#
# NOTE: All speed related behaviours should specify both a speed in m/s
# and a PWM value.
#
# CAUTION: For the extricate behaviour, it would be unwise to make the
# extrication PWM too high.
extricate_pwm = 30

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the lgmd_extricate_emd behaviour also
# supports spin-style steering, i.e., momentarily stopping the robot and
# then turning it cw/ccw in-place. This flag turns on spin-style
# steering. By default, the behaviour uses the normal car-like steering
# mode.
#spin_style_steering = yes

# The extricate behaviour controls both speed and heading. Since it
# needs to kick in after the emergency stop behaviour and be able to
# override that behaviour's instinct to halt the robot, the extricate
# behaviour's priorities need to be higher than or at least equal to
# that of emergency stop.
#
# Additionally, since this behaviour can be configured to use in-place
# turning for steering control, we need to specify an appropriate
# priority for the spin arbiter as well.
turn_priority  = 10
spin_priority  = 10
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 150

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 280 140 140

#---------------- LGMD VFF EXTRICATE BEHAVIOUR SETTINGS -----------------

# This section specifies settings for the LGMD-based VFF version of the
# extricate behaviour, which works by using the LGMD spike rates to
# compute attractive and repulsive forces that are then summed to
# produce a steering vector.
[lgmd_extricate_vff]

# A locust whose LGMD spike rate exceeds a certain threshold will result
# in a repulsive force along the direction in which that locust is
# looking. Conversely, when a locust's LGMD spike rate falls below this
# threshold, it will cause an attractive force. When all the forces are
# put together, we will get a final force vector that can be used to
# drive and steer the robot.
#
# This setting specifies the value of the above-mentioned threshold in
# spikes per second (i.e., Hz). It should be a reasonable value that
# lies within the [min, max] spike range specified in the chosen LGMD
# model's settings section. In case the robot is connected to actual
# locusts, then this setting's value should be some reasonable
# empirically determined value.
threshold = 250

# To prevent this behaviour from becoming overly sensitive, we require
# the LGMD spike rates of a minimum number of locusts to exceed the
# above threshold before the behaviour engages its extrication
# algorithm.
#
# This setting specifies the above-mentioned minimum locust count. It
# should be a reasonable number <= the number of locusts actually
# present.
count = 1

# In some situations, it can be useful to amplify the magnitudes of the
# attractive and repulsive force vectors. These two settings specify
# the values for the amplification factors. Numbers greater then one
# will amplify the vectors; numbers between 0 and 1 will reduce the
# magnitudes of the force vectors; negative numbers will negate the
# directions of the force vectors.
attractive_amplifier = 1
repulsive_amplifier  = 1

# Users may specify what speed they would like the extrication to
# occur.
# 
# CAUTION: It would be unwise to make this speed too high.
extricate_speed = 0.15

# In case the RPM sensor is configured to be bypassed, we will need to
# specify the extricate "speed" in terms of PWM values as well.
#
# NOTE: All speed related behaviours should specify both a speed in m/s
# and a PWM value.
#
# CAUTION: For the extricate behaviour, it would be unwise to make the
# extrication PWM too high.
extricate_pwm = 30

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the lgmd_extricate_vff behaviour also
# supports spin-style steering, i.e., momentarily stopping the robot and
# then turning it cw/ccw in-place. This flag turns on spin-style
# steering. By default, the behaviour uses the normal car-like steering
# mode.
#spin_style_steering = yes

# The extricate behaviour controls both speed and heading. Since it
# needs to kick in after the emergency stop behaviour and be able to
# override that behaviour's instinct to halt the robot, the extricate
# behaviour's priorities need to be higher than or at least equal to
# that of emergency stop.
#
# Additionally, since this behaviour can be configured to use in-place
# turning for steering control, we need to specify an appropriate
# priority for the spin arbiter as well.
turn_priority  = 10
spin_priority  = 10
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 75

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 280 140 140

#---------------- LGMD TTI EXTRICATE BEHAVIOUR SETTINGS -----------------

# This section specifies settings for the LGMD-based TTI version of the
# extricate behaviour, which works by pumping the LGMD spike rates into
# time-to-impact estimators and then computing distances to obstacles
# based on the times-to-impact, finally resulting in a virtual force
# field of attractive and repulsive forces.
[lgmd_extricate_tti]

# Once we have the time-to-impact estimates for all the locusts, the
# lgmd_extricate_tti behaviour uses the robot's current velocity to
# compute obstacle distances in each locust's direction. This, in
# effect, converts the vision-based collision detector into a crude
# range sensor of sorts, which can be used for extrication purposes
# pretty much the same as the LRF-based extricate behaviour, i.e., by
# building a virtual force field.
#
# When a distance estimate is below a certain threshold it will result
# in a repulsive force along the direction in which that locust is
# looking. Conversely, when a distance estimate exceeds the threshold,
# it will exert an attractive force in that locust's direction. The sum
# of all these force vectors will result in a vector that can be used to
# drive and steer the robot away from obstacles.
# 
# This setting specifies the value of the above-mentioned distance
# threshold in millimeters.
threshold = 300

# To prevent this behaviour from becoming overly sensitive, we require
# the distance estimates corresponding to some minimum number of locusts
# to fall below the above threshold before the behaviour engages its
# extrication algorithm.
# 
# This setting specifies the minimum number of distance estimates that
# must fall below the distance threshold before extrication will occur.
# It should be a reasonable number <= the number of locusts actually
# present.
count = 3

# In some situations, it can be useful to amplify the magnitudes of the
# attractive and repulsive force vectors. These two settings specify
# the values for the amplification factors. Numbers greater then one
# will amplify the vectors; numbers between 0 and 1 will reduce the
# magnitudes of the force vectors; negative numbers will negate the
# directions of the force vectors.
attractive_amplifier = 1
repulsive_amplifier  = 1

# When the robot is backing up due to an extrication command, the LGMD's
# fire a small amount. Often, the lgmd_extricate_tti behaviour construes
# this as further actionable input and issues yet more back-up commands,
# which can result in extended periods of reverse driving. These are
# entirely spurious extrications and should not occur. This setting
# helps with the above-mentioned problem by specifying a threshold speed
# (in m/s) that must be met before lgmd_extricate_tti will kick in (or
# interfere).
#
# By setting this to a small positive quantity such as 0.05 or 0.1, we
# can ensure that lgmd_extricate_tti remains passive when the robot is
# backing up (wherein it will report a negative speed). To disable this
# threshold check, simply use a negative number with a magnitude larger
# than the robot's top speed (e.g., -10).
#
# NOTE: Using a large positive number for this setting (e.g., 10) will
# result in effectively disabling the lgmd_extricate_tti behaviour. In
# fact, setting this configuration value to something greater than the
# robot's average cruising speed will pretty much disable the behaviour.
# An easier way to do that is to simply not include it in the config
# file's list of active behaviours. That way, it won't uselessly consume
# CPU and RAM. Therefore, it would be best to stick to a value such as
# 0.05 or 0.1m/s.
interference_threshold = 0.1

# Users may specify what speed they would like the extrication to
# occur.
# 
# CAUTION: It would be unwise to make this speed too high.
extricate_speed = 0.15

# In case the RPM sensor is configured to be bypassed, we will need to
# specify the extricate "speed" in terms of PWM values as well.
#
# NOTE: All speed related behaviours should specify both a speed in m/s
# and a PWM value.
#
# CAUTION: For the extricate behaviour, it would be unwise to make the
# extrication PWM too high.
extricate_pwm = 30

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the lgmd_extricate_tti behaviour also
# supports spin-style steering, i.e., momentarily stopping the robot and
# then turning it cw/ccw in-place. This flag turns on spin-style
# steering. By default, the behaviour uses the normal car-like steering
# mode.
#spin_style_steering = yes

# Normally, this behaviour will only log an entry stating that it made a
# steering decision. However, with this flag, we can make it also log
# the states of each of its time-to-impact estimators.
#
# NOTE: Logging will only take place when the metrics behaviour is
# enabled.
#log_tti_predictions = yes

# The extricate behaviour controls both speed and heading. Since it
# needs to kick in after the emergency stop behaviour and be able to
# override that behaviour's instinct to halt the robot, the extricate
# behaviour's priorities need to be higher than or at least equal to
# that of emergency stop.
#
# Additionally, since this behaviour can be configured to use in-place
# turning for steering control, we need to specify an appropriate
# priority for the spin arbiter as well.
turn_priority  = 10
spin_priority  = 10
speed_priority = 10

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 75

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 280 140 140

#------------------- BAYESIAN TTI ESTIMATOR SETTINGS --------------------

# This section specifies settings for the Bayesian time-to-impact
# estimators used by the lgmd_extricate_tti behaviour.
[tti_estimator]

# In order to estimate the time-to-impact (TTI) from LGMD spike rates,
# we need to discretize the possible TTI values. The TTI estimation
# algorithm works by building a posterior probability distribution over
# the discretized TTI states using recursive Bayesian updates.
#
# The following setting specifies the range and step size of the TTI
# values. It is expected to be a triple of floating point numbers. The
# first two numbers specify the TTI range and the third number specifies
# the step size. For example, if this setting is "0 5 0.01," then the
# TTI space is discretized into 500 possible values starting at zero
# seconds and going up to 5 seconds in increments of hundredths of a
# second.
tti_discretization = 0 10 0.1

# To be able to determine the time-to-impact from LGMD spike rates using
# Bayesian state estimation, we need a sensor model, which is basically
# a probability table specifying the likelihoods of seeing particular
# spike rates from TTI values. The columns of this table specify the
# different ranges for the sensor values, which, in this case, would be
# different ranges of LGMD spike rates. The rows of the table are the
# discretized TTI states (defined with the previous setting).
#
# Robolocust makes use of two sensor models, one each for the two
# "phases" into which it divides the LGMD input signal. The first phase
# is known as LOOMING and corresponds to the portion of the LGMD-vs-TTI
# curve that rises as objects approach. The second phase is referred to
# as BLANKING and corresponds to the portion where the LGMD firing rate
# drops off rapidly after achieving a peak.
#
# Thus, we need two LGMD discretizations for the sensor models. These
# settings specify the LGMD ranges, i.e., the sensor model column
# identifiers, for the two LGMD phases. They should be sorted lists of
# numbers starting at the chosen LGMD model's minimum spike rate and
# going up to the max spike rate.
looming_lgmd_ranges  =   0  75 100 150 200 250 300 \
                       350 400 500 600 700 750 800
blanking_lgmd_ranges =   0 100 200 250 300 350 400 \
                       450 500 550 600 650 700 750 800

# To generate the causal probabilities for the sensor models required by
# Robolocust's Bayesian TTI estimators, we need to know the TTI ranges
# for each of the LGMD phases. These two settings specify that.
looming_tti_range  = 2.5 10
blanking_tti_range = 0 2.5

# When we create the TTI estimation sensor models, we should be careful
# not to insert any zero (or extremely low) likelihoods in it so as to
# avoid numerical instabilities and other pathological conditions. To do
# that, we use a Gaussian weighting formula when updating a sensor
# model's bin corresponding to a given TTI and LGMD to also update the
# other bins in that column.
#
# These settings specify the standard deviations of the Gaussians used
# to weight surrounding bins when creating a sensor model.
looming_sigma  = 1.0
blanking_sigma = 1.0

# In order to actually detect the transition from the LOOMING to the
# BLANKING phase, we monitor the LGMD signal's second derivative to find
# the inflection point wherethe curve becomes concave down (thus
# indicating a local maximum near the signal's peak). Since the
# derivatives of a signal can be quite noisc, it would be best to filter
# the second derivative.
#
# The following setting specifies the size of the low-pass filter used
# to filter the second derivative of the LGMD input signal. For example,
# if this value is 10, then the previous ten readings will be used to
# smooth the second derivative of the input signal. To disable this
# filtering (not recommended), use a filter size of one.
sder_filter_size = 5

# As mentioned above, the LGMD signal is partitioned into two phases,
# viz., LOOMING and BLANKING. We recognize transitions from LOOMING to
# BLANKING using the second derivative of the LGMD input signal and a
# spike rate threshold for the rising portion of the TTI-LGMD curve.
#
# To recognize the transition from BLANKING back to LOOMING, we wait for
# the LGMD signal to fall below some empirically determined threshold
# firing rate rather than relying on higher-order derivatives of the
# input signal.
# 
# These two settings specify the above-mentioned firing rate thresholds
# for recognizing transitions from LOOMING to BLANKING and then back to
# LOOMING.
rising_threshold  = 700
falling_threshold = 100

# Time-to-impact estimates can be combined with the robot's current
# velocity to yield distance "measurements" for each locust. However, we
# only want to use TTI values when their likelihoods are significant.
# That is, if the maximum likelihood in the entire probability
# distribution is really low (e.g., 1%), then it might not be a good
# thing to use that TTI estimate to try and determine the corresponding
# distance. Instead, we want to wait until the confidence level of the
# most likely time-to-impact is a reasonably high value before using it.
#
# This setting specifies the minimum confidence we expect to see before
# a TTI estimate will be used to generate distance readings. It should
# be a number between zero and one.
confidence_threshold = 0.3

# This setting specifies the min and max bounds for the distance
# 'reading" computed by the Bayesian time-to-impact estimator. The units
# for this setting is mm.
distance_range = 50 5000

# There are three visualization modes for the time-to-impact estimator.
# In the first mode, the estimator renders its current belief, i.e., the
# posterior probability distribution computed in each iteration of the
# Bayesian state update loop.
#
# In the second mode, the estimator shows the history of recent
# time-to-impact values predicted by the Bayesian state update. To help
# gauge how well the Bayes filter is doing, the estimator will also
# render the actual TTI values.
#
# In the third mode, the estimator shows the history of recent distance
# "readings" computed using the predicted times-to-impact and the actual
# distancs to approaching obstacles (as reported by the laser range
# finder).
#
# This setting specifies which of the above render modes to use. The
# value of this setting should be a string. As described above, the
# currently supported modes are:
#        off ==> don't perform any rendering
#        bel ==> render current belief
#        tti ==> render time-to-impact histories
#        dis ==> render distance histories
render_mode = off

# The labels used to show the current time-to-impact and other relevant
# info can clutter the visualization quite a bit (especially when the
# locust model drawables are small). This flag can be used to turn these
# labels on or off. By default, the labels are off.
render_labels = no

#-------------------- CALIBRATE LGMD TTI EXTRICATE ----------------------

# This section specifies settings for the behaviour used to calibrate
# the lgmd_extricate_tti behaviour.
[calibrate_lgmd_extricate_tti]

# This behaviour is an interactive one that responds to keypress events
# and updates the sensor models containing the causal probabilities for
# the Bayesian time-to-impact estimation. Robolocust uses two sensor
# models: one for the LOOMING phase of the LGMD signal and the other for
# the BLANKING phase (see explanation in previous section).
#
# To prevent pathological situations, we refrain from having zeros (or
# even extremely low) probabilities in the sensor models by applying a
# Gaussian weighting formula to update bins neighbouring the one
# "pointed" to by various [TTI, LGMD] pairs. The parameter used to
# effect this weighting is a standard deviation for the Gaussian.
#
# When this behaviour starts up, it will set the "input focus" to the
# LOOMING sensor model. Thus, when the user presses the 'k', '+', 'u' or
# 'i' keys, the calibrator will increment the standard deviation of the
# Gaussian used to weight the LOOMING sensor model updates (see above).
# The 'j', '-' or 'd' keys will decrement the Gaussian.
#
# When the user presses the TAB key, the behaviour will set the "input
# focus" to the BLANKING sensor model. The "iku+" and "dj-" keys will
# then affect the BLANKING sensor model's Gaussian. Pressing TAB again
# will switch back to the LOOMING sensor model; so on and so forth.
#
# This setting specifies the amount by which the behaviour should
# increment/decrement the sigma value associated with the
# above-mentioned Gaussian weighting formula.
dsigma = 0.01

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 0 0 640 240

#------------------------- OPEN PATH BEHAVIOUR --------------------------

# This section specifies settings for the open path behaviour, which
# is a turning behaviour responsible for steering the robot towards the
# most open paths that can accommodate its width.
[open_path]

# The open path algorithm looks for paths wide enough to accommodate the
# robot. This setting specifies the target path width in mm.
path_width = 175

# The open path algorithm first builds a list of potential paths and
# then chooses the best one. However, it will only consider paths of a
# certain minimum length. This setting specifies the minimum path length
# (in mm) for a path to be considered a potential candidate.
min_path_length = 250

# Instead of looking for open paths across the laser range finder's
# entire FOV, we can restrict this behaviour to search only some
# subportion of it. The following setting specifies the angular range to
# examine when looking for open paths. It is a single number for each
# side, i.e., a value of 45 will result in the behaviour searching for
# open paths from -45 degrees to +45 degrees.
fov = 90

# Instead of looking for open paths at each angle, we can use this
# parameter to skip some angles. For example, if this parameter's value
# is 10, then the behaviour will look for open paths every 10 degrees.
step = 10

# To ensure that the robot doesn't keep turning unnecessarily, we mark
# some angular range in front of the robot as a dead zone. When the
# most open path lies in this angular range, the open path behaviour
# will simply keep driving straight and not affect the steering.
#
# To disable this policy, simply specify a range that lies outside the
# laser range finder's FOV (e.g., 260 to 280). That way, all open paths
# will lie outside of the dead zone and the robot will always steer
# towards the most open path in every iteration of this behaviour.
# 
# To have the robot never turn towards the most open path, simply use
# the entire FOV of the laser range finder. Then, since all open paths
# will lie in the dead zone, the robot will never turn towards the most
# open path. (Note, however, that an easier way to do this is to simply
# disable the open path behaviour.)
# 
# This setting expects two integers. The first specifies the minimum of
# the dead zone's angular range (usually a negative number indicating
# an angle on the robot's right). The second number is the dead zone's
# maximum (usually a positive number for a direction on the left of the
# robot).
dead_zone = -20 20

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the open_path behaviour also supports
# spin-style steering, i.e., momentarily stopping the robot and then
# turning it cw/ccw in-place. This flag turns on spin-style steering. By
# default, the behaviour uses the normal car-like steering mode.
#spin_style_steering = yes

# The open path behaviour is concerned only with steering the robot and
# not with its translational motion. Therefore, we only need to specify
# the turn priority. However, since it supports both car-like steering
# and differential steering, we should also specify a spin arbiter
# priority.
turn_priority = 9
spin_priority = 9

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 150

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 336 112 112

#---------------------- REMOTE CONTROL BEHAVIOUR ------------------------

# This section specifies settings for the remote control behaviour,
# which can be used to manually control the robot.
#
# NOTE: This behaviour only works with the iRobot Roomba/Create. It
# should not be turned on for other robot platforms.
[remote_control]

# The remote control behaviour works by listening for remote control
# commands. These commands must be sent continuously for the behaviour
# to retain control, i.e., the user must keep pressing the buttons on
# the Roomba Remote in order to maintain manual control of the robot.
# When these commands stop coming in, the behaviour relinquishes control
# and lets the other behaviours function normally.
# 
# This setting specifies the timeout between successive remote control
# commands. Thus, if the remote control behaviour does not sense any
# remote control commands for this much time, it will relinquish control
# of the robot.
# 
# This setting should be a time expressed in milliseconds.
timeout = 1000

# Users may specify the driving speed for remote control commands. The
# speed should be a positive floating point number not to exceed 0.5
# (the Roomba's top speed). Its unit is m/s.
drive_speed = 0.3

# Remote control turn commands can use a different speed setting than
# the drive commands. This setting specifies the turn speed. It is
# expected to be a positive floating point number whose unit is m/s and
# whose value should not exceed 0.5 (the Roomba's top speed).
turn_speed = 0.25

# The remote control behaviour controls both speed and heading. Since it
# should override all other behaviours, its priorities should be the
# highest.
turn_priority  = 100
speed_priority = 100

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 500

# NOTE: This behaviour does not have any visualization.

#---------------------------- OBSTACLE MAP ------------------------------

# Robolocust can be configured to build an obstacle map and keep track
# of its trajectory within this map as it moves around. This section
# specifies settings for this map.
[map]

# Mapping is a fairly intensive process. Thus, when we don't want or
# need this functionality, it would be best to turn it off so as to
# reduce resource usage.
#
# This setting specifies whether mapping should be on or off. By
# default, it is off. If you want mapping, you must turn it on
# explicitly.
enable = yes

# Robolocust uses an occupancy grid for its map. Each cell in this grid
# holds a probability (ranging from zero to 255) indicating the
# confidence level regarding an obstacle in that particular position in
# the map.
#
# To make the map cover a reasonably substantial physical area while
# simultaneously minimizing the amount of memory required to hold the
# grid, we need to discretize the physical space of the robot's
# environment. Thus, each cell in the grid will represent a small square
# area of the environment.
#
# This setting specifies the size of the above-mentioned square (in mm).
cell_size = 10

# The map's extents are specified using [left, right, bottom, top]
# values. These extents are in the physical environment's coordinate
# system (i.e., mm).
extents = 0 5000 -2500 2500

# This setting specifies the minimum probability value a cell in the
# occupancy grid should have for it to be considered as being occupied.
# Cells with probabilities lower than this threshold will be considered
# as free space.
# 
# This parameter's value should be a floating point number between zero
# and one.
occupancy_threshold = 0.95

# As the robot moves around and senses its environment, its internal
# grid update and query algorithms will not always reliably hit the same
# cell over and over (due, for example, to sensor and actuator noise).
# Therefore, when it updates a cell (x,y) in the occupancy grid, lobot
# also updates its immediate neighbours to ensure that subsequent
# queries near (x,y) are not entirely off the mark.
# 
# The following setting specifies a weighting factor to use when
# updating a cell. This factor will applied to the cell in question and
# the remaining weight will be applied to its immediate neighbours. To
# illustrate how this works, let us say the update weight is set to
# 0.75. Then, when the robot updates a cell (x,y), it will apply 75% of
# the update delta (see the "occupancy_deltas" setting defined above) to
# (x,y) and divide the remaining 25% of the delta value equally between
# the remaining 8 cells in the immediate neighbourhood of (x,y). If
# (x,y) is in one of the corners of the map, the remaining 25% will be
# divided equally between the 3 neighbouring cells; if (x,y) is on an
# edge boundary other than a corner, the remaining 25% will be divided
# equally between the 5 immediate neighbours.
# 
# As can be gleaned from the above discussion, the value of this setting
# should be a floating point number in the range [0,1].
# 
# NOTE: Although it is referred to as the "update" weight, this
# parameter is also used when querying the map for occupancy
# likelihoods. Thus, when the robot wants to check the occupancy
# likelihood of some location (x,y), this weighting factor (e.g., 75%)
# will be applied to the actual value stored in that cell and the
# remaining weight (25%) will be divided equally between the immediate
# neighbours of (x,y) to produce a weighted sum for the final occupancy
# value retrieved from the grid.
update_weight = 0.95

# The map provides support for visualizing the obstacle locations as
# well as the current pose. However, this support must be turned on
# explicitly. Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of the map's
# drawing area.
geometry = 0 390 390 390

# Generally, when we draw the map, we also draw the robot's current pose
# w.r.t. the map. However, in some cases, we may wish to skip drawing
# the pose. This setting can be used to do that. By default, it is true,
# i.e., the robot pose is drawn.
#draw_pose = no

# In addition to the pose, the map also draws some labels on its top
# left corner. This setting can be used to turn those labels off. By
# default, they are on.
#draw_labels = no

# To allow users to better make out the map's dimensions and relative
# distances between objects, we can draw a grid. This setting can be
# used to specify the size of the grid's cells, which are all square.
# 
# The value of this setting should be a floating point number. Its units
# are millimeters. If the grid spacing is a negative number, the grid
# will not be drawn. By default, the grid spacing is set to -1 and the
# grid is not drawn.
#grid_spacing = 500

# If the grid is drawn, it will rendered in a light gray color so as to
# not interfere visually with the other things on the map. This setting
# specifies the gray level to use when rendering the map. This setting's
# value is expected to be a unitless number in the range zero to one.
# Lower values will result in a darker grid, higher numbers in a lighter
# grid.
grid_color = 0.75

# This setting controls whether we want to draw a border around the
# map's drawing area within the Robolocust UI. Usually, all drawables
# have borders drawn around them so that they are clearly demarcated
# from each other. However, in some cases, we may not want these borders
# around the map. By default, this flag is on, i.e., a border is drawn.
#draw_border = no

# This setting allows users to customize the color in which the map's
# drawable border is rendered (defaults to yellow). The value of this
# setting should be a triple of integers, each in the range [0,255].
border_color = 255 255 0

#---------------------------- SCAN MATCHING -----------------------------

# To record proper trajectories, Robolocust uses a grid-based FastSLAM
# implementation to build a map and simultaneously record its trajectory
# within this map. Since grid-based FastSLAM is a Rao-Blackwellized
# particle filter that requires each particle to carry its own copy of
# the map being built, we need to somehow reduce the total number of
# particles so as to reduce the overall amount of memory and processing
# requirements of the FastSLAM algorithm.
#
# One way to reduce the particle count is to perform scan matching using
# the laser range finder instead of relying solely on odometry.
# Robolocust uses Besl and McKay's Iterative Closest Point algorithm for
# the scan matching. This section specifies various settings for the ICP
# algorithm.
[scan_match]

# Since different laser range finders have varying capabilities and
# because it would be nice to be able to use the Robolocust
# implementation of the ICP algorithm with devices other than just the
# Hokuyo attached to lobot, it is best to specify the relevant LRF
# characteristics in this config file.
# 
# The first of these numbers specifies the start angle for the range
# readings. Usually, this would be a negative number indicating that the
# laser range finder sweeps from the right to the left.
# 
# The second number specifies the angular step between consecutive range
# readings. For lobot's Hokuyo, this is one degree; but for other LRF's,
# it could be 0.5 degrees.
# 
# Finally, the third number in the above triumvirate specifies the total
# number of range readings.
lrf_specs = -119 1 255

# In each iteration of ICP, the algorithm searches a small angular range
# around each LRF reading to find the best correspondence between the
# current and previous LRF scans. This setting specifies the
# above-mentioned angular search range.
lrf_search_range = 15

# When finding correspondences between the current and previous scans,
# we reject any wherein the LRF range measurements exceed this
# threshold.
outlier_threshold = 100

# The ICP algorithm works by iteratively solving for the rotation and
# translation required to register a data shape with a model shape.
# Initially, the transformation is assumed to be zero. However, we can
# seed the initial transformation using the robot's odometry so that the
# algorithm has a better estimate to start off with. This can reduce the
# amount of work the algorithm has to do to register the previous LRF
# scan with the current one.
# 
# By default, this flag is off so that the implementation follows the
# classic ICP description by Besl and McKay, i.e., starting off with
# zero transformation.
#seed_using_odometry = yes

# Since the ICP algorithm uses multiple iterations to converge to a
# solution, it could (potentially) go on forever. To prevent an infinite
# loop, we use the following setting to specify the maximum number of
# iterations to use.
max_iterations = 30

# In general, the ICP algorithm should converge within a few iterations
# rather than going on for the maximum specified above. In each
# iteration, the algorithm will compute a transformation and a total
# error between the two scans when that transformation is applied.  The
# algorithm will terminate when the difference in this error for two
# consecutive iterations falls below the threshold specified by the
# following setting.
tau = 0.1

#-------------------------------- SLAM ----------------------------------

# As mentioned earlier, Robolocust uses an implementation of the
# FastSLAM algorithm to build an occupancy map of its surroundings and
# to record its trajectory as it avoids obstacles. This section
# specifies settings for the SLAM subsystem.
[slam]

# The FastSLAM algorithm is a Rao-Blackwellized particle filter. This
# setting allows us to configure the number of particles to use.
num_particles = 500

# In order to cut down on the amount of processing required by the
# FastSLAM algorithm and also to preserve particle diversity, Robolocust
# will only resample the particle population when the variance of the
# particle weights becomes high (thus indicating a lot of spread and
# high uncertainty in the state estimate).
# 
# To make the actual determination as to when to resample, Robolocust
# computes the effective sample size by taking the reciprocal of the sum
# of the squares of all the particle weights. When the effective sample
# size (ESS) drops below some threshold, the particle filter's
# resampling step will kick in.
# 
# The following setting specifies the effective sample size threshold.
# Usually, a good value to use for it would be half the number of
# particles. However, to disable the ESS check, you may set this to a
# zero or to a value greater than the number of particles. In that case,
# resampling will take place after each and every iteration of the SLAM
# update.
ess_threshold = 250

# During resampling, it might be a good idea to introduce some random
# particles just in case the filter has arrived at an incorrect state
# estimate. However, we don't want to insert random particles all the
# time.
# 
# Therefore, Robolocust tracks the averages of the particle weights and
# inserts random particles only when the short-term average performs
# poorly w.r.t. the long-term average. An exponential filter is used to
# smooth the short and long-term particle weight averages to ensure that
# momentary glitches don't get misconstrued as incorrect state
# estimates.
# 
# The following setting specifies the values of the exponential decays
# to use for filtering the short and long-term averages. These values
# are plugged into a running average formula for computing the averages.
# The long-term average's decay parameter must be much less than that of
# the short-term average.
# 
# This setting expects to be given two numbers. The first is the decay
# parameter for the short-term average and the second is the decay
# parameter for the long-term average. Both numbers must lie between
# zero and one.
alpha = 0.85 0.05

# This setting specifies the robot's initial pose. It is expected to be
# a triple of floating point numbers. The first two numbers specify the
# (x, y) coordinates of the robot on start-up and the third number
# specifies its bearing (in degrees).
initial_pose = 0 0 0

# When the robot moves, it will experience some amount of translational
# and rotational slip. The following parameter captures these errors and
# they are used in the prediction step of the FastSLAM algorithm.
#
# The value of this setting is expected to be a triple of floating point
# numbers. The first two numbers specify the amount of translational
# error (in mm) to expect in the x and y directions respectively. The
# third number specifies the amount of rotational error in degrees.
#
# NOTE: Ideally, these parameters will be empirically determined via
# either manual experiments designed to characterize and quantify
# systematic odometric errors or via some automated learning approach
# based on sample data.
errors = 2.5 2.5 0.5

# Like all Bayesian filters, the FastSLAM algorithm has a prediction
# step, wherein the latest control command is used to predict a new
# state, and a correction step, wherein the latest sensor data is used
# to correct the state prediction. Since a laser range finder serves as
# lobot's primary sensing modality, the Robolocust implementation of
# FastSLAM employs a probabilistic beam model in its correction step.
# This beam model involves ray tracing, a computationally intense
# operation. To cut down on the number of rays to be traced, we can
# configure Robolocust to consider only some of the distance
# measurements returned by the laser range finder.
# 
# The following setting allows us to do that. It is expected to be a
# triple of integers. The first two numbers specify the starting and
# ending angles to consider (e.g., from -90 to +90 degrees). The third
# number is a step size. Thus, for example, if the beam_specs setting is
# "-90 90 15," then the FastSLAM algorithm will only consider the laser
# range finder readings corresponding to -90, -75, -60, -45, -30, -15,
# 0, 15, 30, 45, 60, 75 and 90 degrees, which makes for a total of 13
# ray tracing operations instead of (potentially) > 180.
# 
# NOTE: Limiting the field of view of the laser range finder speeds up
# the FastSLAM algorithm but at the expense of map accuracy.
beam_specs = -90 90 15

# The probabilistic beam model mentioned above works by computing the
# expected range reading from the current state estimate (i.e., robot
# pose and occupancy map) and then seeing how well the actual distance
# measurements match the expected ones. Particles with good state
# estimates should match the actual sensor data better than those with
# poor estimates. Thus, good particles will get higher weights and the
# particle filter will pick those particles while culling the poor ones
# from the particle population.
# 
# To rate the state estimates made by different particles, we run the
# actual range reading through the formula for a normal distribution
# centered at the expected range. This will produce a number that we can
# use for the particle weight. The following setting specifies the
# standard deviation for the above-mentioned application of the normal
# distribution formula. It is a distance (in mm).
# 
# The value of this setting should reflect the amount of error we are
# willing to tolerate between the estimated range readings and the
# actual ones. It should also take into account the discretization
# parameters of the occupancy map.
beam_model_sigma = 75

# The beam model described above computes the likelihood of a single
# distance measurement. Since the laser range finder returns multiple
# distance readings, we have to multiply the individual beam
# probabilities to obtain the final/total measurement likelihood.
# 
# Unfortunately, as each beam's probability is a number between zero and
# one, multiplying the individual probabilities together will very
# rapidly result in extremely small numbers: of the order of ten raised
# to -50. This causes floating point instabilities.
# 
# To work around this problem, we multiply individual beam probabilities
# by a large constant and multiply the resulting numbers instead of the
# original [0,1] likelihoods. The following setting specifies the value
# of the above-mentioned large constant.
beam_prob_fudge_factor = 1000

# For the beam model described above to work, we need to specify the
# minimum and maximum range readings the laser range finder can produce.
# Although the robot can determine this directly from the device itself,
# depending on the environment and on other factors, we may want the
# FastSLAM algorithm to consider a range different from the device's
# actual range. This setting allows us to do that. Its value should be
# two floating point numbers. The first one specifies the beam's minimum
# range (in mm) and the second one its maximum range (again in mm).
beam_range = 60 5600

# During the map update step, the SLAM algorithm uses each distance
# measurement to determine which cells in the occupancy grid are
# occupied. Since the grid is a discretized version of the world, there
# will, naturally, be discrepancies between the actual distance reading
# and the same range in grid coordinates.
# 
# This setting specifies the amount of discrepancy that should be
# tolerated. As an example of how this works, let's say that the value
# of this setting is set to 100mm and that we get a reading (in some
# direction) of 622mm. Then, depending on the map's discretization
# parameters, as the algorithm traces the distance measurement within
# the occupancy grid in order to find the cell at which the measurement
# ends, it will accept a cell that is within 100mm of 622, i.e., from
# 522 to 722mm.
occupancy_range_error = 50

# As we know, in a particle filter, each particle makes a guess about
# the current state. These guesses are, of course, not entirely random;
# rather they are the result of probabilistic motion and sensor models.
# Good guesses, i.e., ones that match the sensor data, get more weight
# while poor ones are assigned lower weights and get filtered out. The
# overall state of the robot can then be gleaned by analyzing the
# particle population's density.
# 
# There are many ways to perform particle density analysis. The one used
# by Robolocust's FastSLAM implementation works in the following manner:
# 
#    1. First, find the particle with maximum weight
#    2. Then, find K particles whose states most closely match that of
#       the above particle
#    3. Compute the current state as the average of these K states
# 
# The following setting specifies the value to use for K. It is
# specified as a percentage of the total number of particles. To use
# just the particle with max weight and not bother with computing the
# average of the top K particles, set this value to a negative number.
kmeans_percentage = 10

# Since odometry tends to be more error-prone than a laser range finder,
# Robolocust can be configured to use a scan matching algorithm to
# correct the raw odometry and use the corrected values to compute pose
# updates in the filter's prediction step. The following flag can be
# used to turn scan matching on or off (default is off).
#scan_matching = on

#-------------------------- SURVEY BEHAVIOUR ----------------------------

# The survey behaviour is responsible for building the obstacle map. It
# does so using the laser range finder measurements and updating the
# occupancy grid using a SLAM algorithm.
[survey]

# Since SLAM updates can be quite intense, the survey behaviour waits
# for the robot to move or turn by at least some minimum amount before
# triggering the SLAM algorithm. This setting specifies the
# above-mentioned thresholds. The distance threshold is in mm and the
# angle threshold in degrees.
#
# NOTE: This setting expects its value to be two integers. The first
# number is used for the distance threshold and the second for the angle
# threshold. Set these values to -1 to turn the thresholds off.
thresholds = 100 5

# Sometimes the low-level controller goes berserk and sends nonsensical
# odometry packets. This setting specifies maximum acceptable values for
# the distance and rotation sent by the low-level. Values greater than
# these thresholds will be reported on stderr but ignored for SLAM
# updates.
odometry_max = 200 30

# Although SLAM is designed to learn a map and localize the robot at the
# same time, we can configure the Robolocust system to only perform
# localization given a known map. The following setting specifies a file
# name for a map. The robot will read this map during initialization and
# then localize itself w.r.t. this map using the Monte Carlo
# Localization component of the SLAM algorithm.
# 
# The map file is expected to be a plain text file containing
# coordinates of obstacles. Each obstacle is specified using four
# coordinates. The first two coordinates specify the location of the
# lower left corner of a rectangle where the obstacle "begins" and the
# next two are for the upper right corner where the obstacle "ends."
# 
# The coordinates are all expressed in the map's real/physical
# coordinate system.
#map_file = /tmp/lobot.map

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1500

# The Robolocust FastSLAM implementation supports visualization. When
# this flag is turned on, each particle will be drawn on the map so we
# can tell where the particles are, how dispersed or densely located
# they are, etc.
#
# NOTE: Each particle hypothesizes the robot's current pose as well as
# the map. However, only the final map computed from all the particles
# is shown on the Robolocust main window.
#
# NOTE 2: Since this behaviour's visualization consists of drawing
# particles on the map's drawing area, there is no need to specify
# geometry settings for it.
visualization = on

# By default, the visualization only shows the particle positions.
# However, this setting can be used to also show the particle bearings.
#show_bearings = yes

# NOTE: This behaviour does not actually perform any motor actions.
# Thus, it does not need turn and speed priorities.

#--------------------------- GOAL BEHAVIOUR -----------------------------

# This behaviour drives the robot toward each goal in a list of goals.
# The goals are specified in terms of the localization module's map.
# Thus, the survey behaviour must be on for this one to work properly.
[goal]

# A goal is a rectangle specified in map coordinates. The behaviour will
# direct the robot towards the center of each goal rectangle. However,
# the goal is considered satisfied when the robot is located anywhere
# within the target rectangle.
#
# This setting specifies a list of goals. Each goal is specified using
# four numbers, viz., left, right, bottom and top.
goals = 4400 4900 -250 250 \
         100  600 -250 250

# This behaviour can be configured to actively steer the robot to each
# goal or to simply monitor the robot's current location to check if the
# robot is at a goal or not. When set, this flag will make the goal
# behaviour actively seek each goal in the above list. By default, this
# flag is off, i.e., the behaviour only monitors the robot's location
# without affecting its steering in any way.
#actively_seek_goals = yes

# What should we do when we reach a goal? The options are:
# 
#    - continue on to the next goal
#    - pause robot and wait for user to start it moving again
# 
# This setting specifies which of the above two actions to use. By
# default, the goal behaviour implements the "continue" action, i.e.,
# when the robot reaches a goal, it simply carries on to the next one.
# However, by setting this flag, the behaviour will pause the robot and
# wait for the user to explicitly signal resumption of normal
# operations.
#pause_at_goal = yes

# By default, when the final goal in the goal list is reached, the goal
# behaviour will maintain that goal. Thus, if another behaviour causes
# the robot to move away from the final goal in the goal list, the goal
# behaviour will redirect the robot back to that goal.
# 
# However, by setting this flag, we can have the goal behaviour loop
# back to the first goal in the list and start over.
#loop = yes

# In loop mode, instead of starting over at the first goal, we can have
# the goal behaviour backtrack over the goal list, i.e., seek each of
# the goals in reverse. This flag enables backtracking. It is off by
# default.
#backtrack = yes

# When configured to actively steer the robot towards goals, the goal
# behaviour directs the robot towards the current goal by implementing
# the VFF method described by Borenstein and Koren (see "Real-time
# Obstacle Avoidance for Fast Mobile Robots," IEEE Transactions on
# Systems, Man, and Cybernetics 19(5):1179--1187, Sep/Oct 1989).
# 
# The following setting specifies the size of the active window within
# the certainty grid (i.e., occupancy map). This size is specified in
# terms of the number of cells occupied by the active window.
# 
# NOTE: Actually, this setting specifies half of the active window's
# size. That is, internally, this number is doubled.
#
# NOTE 2: If this setting is not specified, the goal behaviour will
# decide on a reasonable value based on the map discretization and robot
# size. In fact, it might be better to just let the behaviour pick an
# appropriate window size.
vff_window_size = 24

# The VFF method mentioned above computes a repulsive force vector for
# each cell within the active window and an attractive force vector for
# the goal. The sum of all the repulsive forces and the single
# attractive force result in a final steering vector.
# 
# This setting specifies the force constants to use for the individual
# force vectors. It should be a pair of numbers. The first number is
# the repulsive force constant and the second one is the attractive
# force constant.
vff_forces = 100 1000

# Usually, steering control is effected using the turn arbiter, which
# veers the robot in different directions while it moves, i.e., smooth
# car-like turns. However, the goal behaviour also supports spin-style
# steering, i.e., momentarily stopping the robot and then turning it
# cw/ccw in-place. This flag turns on spin-style steering. By default,
# the behaviour uses the normal car-like steering mode.
#spin_style_steering = yes

# The goal behaviour simply steers the robot towards the current goal.
# Hence we only need to specify a turn priority for this behaviour.
# However, since this behaviour also supports spin-style steering, we
# should also supply a suitable priority for the spin arbiter.
turn_priority = 8
spin_priority = 8

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1750

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# behaviour's drawing area.
geometry = 480 336 112 112

# In addition to rendering its steering votes, the goal behaviour can
# also render the goal list on the Robolocust map. This flag turns on
# goal list rendering. It is off by default.
#render_goals = on

#--------------------------- TRACK BEHAVIOUR ----------------------------

# The track behaviour maintains the robot's pose history. This behaviour
# does not control the robot in any way; it is only meant for data
# collection and visualization.
[track]

# This behaviour's visualization consists of a dotted "trail" drawn on
# the Robolocust map. By default, visualization is off.
#
# NOTE: Since this behaviour's visualization entails drawing on the
# map's drawing area, there is no need to specify geometry settings for
# it.
visualization = on

# This setting specifies the amount of pose history that should be used
# when drawing the trail.
history_size = 25

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 1000

# NOTE: This behaviour does not actually perform any motor actions.
# Thus, it does not need turn and speed priorities.

#-------------------------- METRICS BEHAVIOUR ---------------------------

# This behaviour collects all sorts of useful data as lobot runs. For
# example, we can get information such as the robot's pose history, the
# time at which a goal is reached, average speed of the robot, number of
# emergency stop and extrication events, actual and predicted
# times-to-impact, and so on.
#
# This behaviour does not control the robot in any way nor does it
# perform any sort of visualization.
[metrics]

# This setting specifies the prefix of the file name to which the
# metrics should be written. By default, it is "/tmp/lobot-metrics-".
# 
# The remainder of the metrics log file's name is generated using the
# application start time in the format "yyyymmdd-HHMMSS". There is no
# file name extension.
log_prefix = /tmp/lobot-metrics-

# The metrics behaviour buffers all the metrics related messages sent by
# other behaviours and, periodically, when the buffer is "full," dumps
# the buffer to the log file. This setting specifies the minimum number
# of messages that should be collected before the internal buffer will
# be written to disk and cleared.
dump_threshold = 500

# Most log messages begin with a small descriptive phrase such as
# "tracking pose" or "emergency stop" and are then followed by some
# values (such as the pose alluded to in the afore-mentioned phrase). To
# make the log more readable, all the opening phrases are written
# left-justified in a field width specified by this setting.
opening_phrase_width = 20

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 2500

# NOTE: This behaviour does not perform any motor actions or
# visualization. Thus, it does not need turn and speed priorities or
# visualization related parameters.

#---------------------- RENDER RESULTS BEHAVIOUR ------------------------

# This section specifies settings for the render_results behaviour, an
# offline, visualization task designed to read the metlog and results
# files output by the lobot and lomet programs respectively in order to
# render the various point lists (robot's trajectory, locations where
# the extrication behaviours were active, etc.) on the obstacle map.
#
# This behaviour is intended to leverage the map rendering capabilities
# already built-in to the Robolocust UI so as to quickly get screenshots
# that can then be included in papers, etc.
[render_results]

# This setting specifies the name of the directory under which all of
# the lobot and lomet programs' results files are stored. By default,
# this string is empty. If the render_results behaviour is active and
# this setting is not explicitly provided, the Robolocust application
# will report an error but continue to function (although it would not
# fulfill its intended purpose).
results_dir =

# This setting specifies a regex pattern for the names of metrics log
# and dataset analysis results files. We assume that the lobot and lomet
# programs were used to output metrics logs and results files for
# different experiments/datasets under different subdirectories of a
# root data directory. If this assumption is not valid, the
# render_results behaviour cannot and will not work properly.
# 
# When this behaviour starts up, it will search the data directory
# recursively for all files matching the name specified by this setting.
# The value of this setting should be a string and it is interpreted as
# an extended regular expression (try: man 7 regex). Thus, all files
# under the data directory whose names (relative to the data directory)
# match the regex specified by this setting will be included in the list
# of files to be loaded and visualized.
# 
# After finding the list of files to be visualized, the render_results
# behaviour will then proceed to load the first of these files. You may
# use the 'n' (next), 'f' (forward), '+' or space keys to advance to the
# next file in the list. To visit the previous file in the list, press
# 'b' (back) or '-'. When either end of the list is reached, the
# behaviour will continue by simply wrapping around to the other end.
# 
# This behaviour also supports saving the visualizations using the 's'
# (screenshot) key. When the 's' key is pressed, the behaviour will
# write an image to the same location as the metlog or results file
# currently being visualized. In fact, the screenshot's file name is
# simply the metlog or results file's name plus an extension.
# 
# The default extension is ".png". To save the screenshot as a JPEG
# file, set the "screen_capture_fmt" option in the "[ui]" section of the
# config file to "jpg". Other image formats are also supported; check
# the documentation of the screen_capture_fmt option for more
# information.
results_file_name = (lrf|emd|vff|tti)/([[:digit:]]{3}/)?(metlog-[[:digit:]]{8}-[[:digit:]]{6}|result)$

# In addition to the robot's trajectory from start to goal, each
# experiment's metrics log or a dataset's results file records the
# following lists of points:
#     - bump: where the robot bumped into objects
#     - stop: where the emergency_stop behaviour was activated
#     - extr: where the LRF-based  extricate behaviour was activated
#     - lgmd: where the LGMD-based extricate behaviour was activated
#
# The following flags can be used to turn the rendering of each of the
# above lists on or off. By default, the render_results behaviour
# renders all the lists.
#render_bump_points = no
#render_stop_points = no
#render_lrf_extrication_points  = no
#render_lgmd_extrication_points = no

# These settings specify the colors to use for the different point
# lists. They should all be triples of integers, each in the range
# [0,255].
bump_points_color = 255   0 0
stop_points_color = 255 165 0
lrf_extrication_points_color  =   0   0 255
lgmd_extrication_points_color = 105 139 105 

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
#
# NOTE: The render_results behaviour draws everything it needs to on the
# obstacle map drawable. However, in order to be able to respond to
# keyboard input, its drawable still needs to be added to the Robolocust
# UI. Therefore, we need to enable this behaviour's visualization.
#
# NOTE 2: Since this behaviour does not have anything to render in its
# own drawable area, its geometry is set internally to have negative
# dimensions so that its drawable is treated as being invisible.
# Therefore, specifying a geometry for this behaviour will not result in
# an "emtpy" drawable showing up (because the geometry setting here will
# simply be ignored).
visualization = on

# The render_results behaviour supports a slideshow mode, wherein it
# periodically switches to the next metlog or results file in its list.
# The behaviour's update_frequency setting controls the rate at which
# the slideshow progresses.
#
# By default, slideshow mode is turned off.
#slideshow = yes

# This behaviour can visualize the metrics logs for individual
# experiments as well as the results file containing the analysis for an
# entire dataset. In slideshow mode, when we get to a dataset results
# file after a long string of metlogs, we might want to pause the
# slideshow in order to be able to study the average-case behaviour in
# greater detail.
# 
# This flag allows us to do that. By default, it is off. When it is
# turned on and we reach a dataset's results file, the slideshow will
# pause. To restart the slideshow, press the 'p' key.
#pause_on_dataset = yes

# The number of milliseconds between successive iterations of this
# behaviour.
# 
# NOTE: Whereas the update_delay setting for most behaviours is a
# crucial parameter that can disrupt proper robot operation, it is only
# used to control the slideshow rate for the render_results behaviour,
# which is just an offline, visualization task.
update_delay = 2500

#------------------ VECTOR FIELD HISTOGRAM BEHAVIOUR --------------------

# This section specifies settings for the VFH behaviour, which performs
# robot navigation and obstacle avoidance based on a repulsive vector
# field.
[vfh]

# The VFH behaviour is basically an obstacle avoidance strategy. But it
# also governs the robot's speed in addition to its heading.
turn_priority  = 9
speed_priority = 9

# The number of milliseconds between successive iterations of this
# behaviour.
#
# WARNING: The ability to change a behaviour's update frequency is a
# very powerful feature whose misuse or abuse can wreak havoc! Be sure
# to use reasonable values for this setting.
update_delay = 150

# Each behaviour provides support for visualizing what's going on
# under the hood. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

#--------------------------- ROBOT SETTINGS -----------------------------

# The Robolocust controller has support for several different robot
# platforms. This section specifies the settings that can be used to
# tweak the controller's operation on different platforms.
[robot]

# Do we want to actually use the robot's sensorimotor system? For
# example, if we're testing something and only want to observe some
# aspects of a behaviour (say) but don't really want the robot to
# move...
#use_robot = no

# The Robolocust controller can work with different kinds of robots as
# long as there exists some code to interface with the underlying
# platform's motor primitives. This setting specifies the platform name.
#
# Originally, Robolocust was written to work on a modified R/C car. That
# platform is referred to as "rc_car". Later on, support for iRobot's
# Create platform was added. The iRobot Create can be used either with
# or without its Command Module. When the Command Module is used, the
# robot platform is known as "roomba_cm"; without the Command Module,
# the platform is referred to as "roomba_direct".
#
# As of now, Robolocust supports the following robot platforms:
#     rc_car    roomba_cm
#
# Use one of the above strings for this setting's value.
platform = roomba_cm

# Usually, the physical robot platform will have a microcontroller
# on-board that will interface with the low-level electromechanical
# subsystems. The high-level controller will send drive commands and
# sensor queries to this microcontroller via a serial port.
#
# These settings specify the serial port device and communication speed
# to use.
serial_port = /dev/ttyUSB0
baud_rate   = 57600

# This size of the robot (in mm).
#
# NOTE: This size usually refers to the robot's width or diameter.
size = 400

# The iRobot Create/Roomba turns by using an appropriate turn radius.
# However, the higher layers of the Robolocust controller work in terms
# of a steering direction rather than a turn radius. Therefore, we have
# to somehow convert the high-level steering angles to corresponding
# low-level turn radii.
# 
# This conversion is rather ad hoc. We simply perform a linear
# interpolation on the magnitude of the turn angle, which would be in
# the range [0, T] (where T is the turn_max parameter specified in the
# turn_arbiter section), to get a number in the range [M, m], where m
# and M and are, respectively, the minimum and maximum turn radii we
# want.
# 
# The Create/Roomba supports turn radii of 0 to 2000mm.  However, these
# min and max parameters should be smaller than the above range, i.e.,
# min_turn_radius should be > zero and max_turn_radius should be < 2000.
#
# Both parameters are specified in millimeters.
min_turn_radius =  200
max_turn_radius = 1000

# For the Roomba platform, we compute the robot's current speed by
# asking the Roomba how much distance it has covered since the previous
# update of the speed. We then divide this distance by the amount of
# time that elapsed since the previous update.
#
# For the most part this computation works quite well, with the computed
# values being quite close to the actual/requested speed. However, there
# is enough jitteriness in these speed readings to warrant a simple
# low-pass filter to smooth out the kinks.
#
# The above-mentioned low-pass filter is effected by using a weighted
# moving average. This setting specifies the number of previous readings
# that should be considered for computing this average.
#
# NOTE: To turn the speed filter off, set this config value to one.
speed_filter_size = 10

# The Roomba platform is equipped with a pair of Sharp GP2D15 IR
# proximity detectors on its rear to help the robot avoid bumping into
# things as it backs up. However, these two sensors have to be
# explicitly turned on. The following flag can be used to configure the
# rear bump sensors.
#enable_rear_bumps = yes

# When the Roomba platform's rear bump sensors are enabled, the robot
# will respond to rear bump events in one of two ways:
#
#    - just stop the robot when either of the two rear bumpers is active
#
#    - stop the robot, spin it in-place a small amount either clockwise
#      or counterclockwise depending on which side the obstacle appears
#      and then move it forward a little bit
#
# By default, the low-level controller will respond to rear bump events
# by simply stopping the robot. However, this flag can be used to have
# the robot spin and move-up as well.
#rear_bumps_spin = yes

# The R/C car platform has an RPM sensor attached to one of its wheels.
# To convert the RPM readings into corresponding speed values, it needs
# to know the diameter of the robot's wheels. The diameter is a floating
# point number and its dimensions are expected to be mm.
wheel_diameter = 139.70

# The higher layers of the Robolocust controller specify drive commands
# in terms of a speed expressed in m/s. The R/C car platform's low-level
# motor system, however, needs to be commanded in terms of a PWM duty
# cycle. To convert speed commands to appropriate PWM values, we first
# convert the target speed set by some high-level behaviour/module into
# RPM and then just multiply the result with some suitable conversion
# factor.
# 
# The following setting specifies the value of the above-mentioned
# factor. It would usually be a number between 0 and 1.
rpm_pwm_factor = 0.25

# The R/C car platform's RPM sensor is quite noisy. To work around this
# problem, we filter its readings using a weighted moving average. This
# setting specifies the number of previous readings that should be
# considered for computing the weighted moving average.
#
# NOTE: Although inadvisable, the RPM filter can be turned off by
# setting this config value to one.
rpm_filter_size = 10

# Despite the above-mentioned filtering, the R/C car platform's RPM
# sensor can still be noisy and very unreliable (probably due to a bug
# in the low-level Propeller microcontroller's SPIN code). Thus, we may
# want to turn the dang thing off completely. That can be achieved by
# turning the following flag on.
#bypass_rpm_sensor = yes

# The R/C car platform's motor subsystem uses a PID controller to
# achieve and maintain the target speed commanded by high-level
# behaviours and modules. This setting specifies the PID gains for the
# speed controller. It should be three floating point numbers. Be
# careful to use sane values for these gains; else, things can go quite
# wrong...
speed_gains = 1.00 0.01 0.0

# The R/C car platform's steering servo can be commanded to turn the
# robot's wheels left or right by sending it PWM values from -100 to
# +100 respectively (zero indicates drive straight ahead). However,
# commanding the servo to its maximum range (i.e., -100 or +100) seems
# to cause a certain amount of mechanical stress to the robot's steering
# assembly and the servo motor itself.
#
# Therefore, it is recommended that the steering servo not be commanded
# to its full range. This setting specifies the max PWM value for the
# steering servo. It would be best to keep this value somewhere between
# 50 and 90; the default is 75.
max_steering_pwm = 75

# Robolocust can be configured to print useful info such as current
# speed and heading every time the robot's sensorimotor system gets
# updated. By default, the Robolocust controller prints nothing. To
# enable this printing, switch on this flag.
#print_status = yes

#--------------------- LASER RANGE FINDER SETTINGS ----------------------

# This section is for configuring the Hokuyo laser range finder
# connected to lobot.
[laser]

# This setting allows us to enable or disable the entire laser range
# finder I/O subsystem.
#use_laser = no

# The Robolocust controller has support for reading distance
# measurements from a Hokuyo laser range finder. This sensor connects to
# the host system via a USB port. The following settings specify the
# serial port device and the communication speed to use for the Hokuyo
# LRF.
serial_port = /dev/ttyACM0
baud_rate   = 115200

#--------------------------- VIDEO SETTINGS -----------------------------

# This section specifies various video related settings (e.g., whether
# or not record the input frames being grabbed from FireWire cameras,
# the recording bit rate, and so on).
[video]

# This setting allows us to enable or disable the entire video I/O
# subsystem.
#use_video = no

# The Robolocust/lobot code supports grabbing video frames from FireWire
# cameras at two resolutions, viz., 160x120 and 320x240. Only these two
# resolutions are supported because Robolocust was developed with
# Unibrain Fire-i cameras that support grabbing at 30 fps at these two
# resolutions.
#
# The following setting specifies the video grab resolution. It must be
# a string of the form WxH. Don't use any spaces or other extraneous
# characters; otherwise, lobot will fall-back to using its hard-coded
# default. Also, note that any resolution other than the two mentioned
# above will be ignored and, once again, the programs will fall-back to
# their hard-coded defaults.
grab_size = 160x120
#grab_size = 320x240

# Robolocust supports grabbing video from FireWire cameras at various
# frame rates. These are the same rates supported by libdc1394. However,
# not all combinations of frame rates and resolutions will work.
#
# This setting must be a floating point number and is interpreted as
# "frames per second."
#grab_rate = 3.75
#grab_rate = 7.5
grab_rate = 15
grab_rate = 30

# The following configuration variable specifies whether or not input
# frames should be recorded to MPEG movies. This feature is useful for
# recording what the robot sees as it moves about and then sending those
# movies to the Gabbiani team at the Baylor College of Medicine (in
# Houston, Texas) so that they can show the movies to actual locusts and
# send us back LGMD spike trains that we can use to better test our
# integration algorithms.
#
# If this setting is omitted from the config file, input frames will not
# be recorded. If specified, it should supply the "root" name of the
# MPEG files to which the camera inputs will be sent. For example, let
# us say we have 3 cameras connected to the robot. Then, this "root"
# name will have 0, 1 and 2 appended to it to indicate the recorded
# streams for each of the 3 cameras.
#
# Moreover, the MPEG "root" name should not have any extension in it.
# The file extension will be automatically appended by the ffmpeg
# encoding module used internally by the Robolocust/lobot code.
#
# So, for instance, we might set this variable to something like
# "/home/foo/bar" and the input frames from 3 cameras will get stored in
# /home/foo/bar-0.mpeg, /home/foo/bar-1.mpeg and /home/foo/bar-2.mpeg
# (assuming the MPEG1VIDEO codec is used; other codecs will result in
# other file name extensions).
#
# Since encoding movies is a fairly intensive operation, this should
# usually be commented out.
#record = /tmp/lobot

# This setting specifies the codec to use for encoding input frames
# streaming in from the robot's FireWire cameras and storing them in a
# movie file. It also specifies the codec to use for decoding MPEG
# files when Robolocust is configured to get its input from MPEG files.
# Any of the codecs supported by ffmpeg/libavcodec (and installed on the
# system) may be used.
#
# NOTE: To see a list of available codecs, use the value "List". This
# will cause the Robolocust programs to print the codec names and
# terminate. Pick one from the list and put that here.
recording_codec = mpeg
#recording_codec = avi

# The following configuration variable governs whether input frames
# will be read from MPEG files or directly from FireWire cameras. If it
# is not set in the config file, the Robolocust programs will attempt
# to capture their input from cameras connected to the FireWire bus.
# Otherwise, they will try to get their input from the specified MPEG
# files.
#
# This capability is useful for testing the different LGMD spike
# generation models with artificial stimuli. For example, if we wanted
# to see whether the directionally sensitive motion detectors
# implemented in the Stafford model work properly, we could supply an
# MPEG of a black box moving across a white background and set the
# appropriate weights in the stafford section of this file to ensure
# that only the DSMDs fire.
#
# Like the "record" variable, this variable's value must also be an
# MPEG "root" name without any extension. This allows multiple MPEG
# files to be read in and composited together just as multiple cameras
# are. Thus, for example, if we have three MPEG files, viz.,
# /home/foo/bar-0.mpg, /home/foo/bar-1.mpg and /home/foo/bar-2.mpg, we
# would set the value of the following variable to "/home/foo/bar". the
# Robolocust/lobot programs will automatically append the "-0.mpg",
# "-1.mpg" and "-2.mpg".
#play = /tmp/lobot
#play = /lab/mviswana/robolocust/videos/artificial-stimuli/boxapproach
#play = /home/mvnathan/academics/usc/research/robolocust/videos/boxapproach

# This setting specifies the codec to use for decoding MPEG files when
# Robolocust is configured to get its input from MPEG files.
#
# NOTE: To see a list of available codecs, use the value "List". This
# will cause the Robolocust programs to print the codec names and
# terminate. To pick an appropriate codec automatically, use the value
# "Auto".
playback_codec = Auto

# These settings control various aspects of the encoding and decoding
# process. The defaults ought to be okay. Change with caution and only
# if you really know what you're doing.
bit_rate        = 400000
frame_rate      = 25
frame_rate_base = 1
buffer_size     = 100000

#------------------------ STAFFORD LOCUST MODEL -------------------------

# The settings in this section twiddle various knobs in an effort to
# sanify the LGMD model described in a couple of papers by Stafford,
# Yue, Rind and gang. This model is implemented in LoStafford.[CH].
# Consult the sources for more info.
[stafford]

# This setting specifies how wide (in pixels) each locust's FOV is. It
# will be clamped to lie between some predefined minimum (usually 16
# pixels) and the total width of the combined input images from all
# video sources.
#
# Increasing this number will decrease the total number of virtual
# locusts; decreasing it will increase that number.
#
# Note that this FOV is really just a maximum. That is, while creating
# the requisite number of virtual locusts necessary to cover the entire
# input image, the program may have left-over bits on the sides and,
# thus, the FOVs of these outer locusts could be smaller than the number
# specified here. Generally though, this little bit of internal arcana
# should not create too much trouble.
locust_fov = 48

# Each virtual locust's FOV may overlap a little with that of its
# neighbours. The following setting specifies the number of pixels of
# overlap. For purposes of sanity, it is clamped to lie between zero and
# half of the locust_fov.
#
# Decreasing this number (while keeping the locust_fov constant) will
# result in fewer virtual locusts; increasing it will increase the
# number of locusts required to cover the entire input image.
fov_overlap = 24

# LGMD, FFI and DSMD spikes are computed by scaling down their raw
# membrane potentials to number in the range [.5,1] and then checking if
# the result exceeds a threshold or not. The following setting specifies
# the thresholds for each of the above-mentioned neurons.
#
# Since there are 6 neurons the Stafford model implements, this setting
# consists of a list of 6 numbers. The first one is the threshold for
# the LGMD; the second one is the threshold for the FFI cell; and the
# remaining four are the thresholds for the left, right, up and down
# neurons.
#
# NOTE: Lateral motion suppression using feed-forward inhibition and the
# directionally sensitive motion detecting neurons (i.e., FFI and DSMDs)
# does not work very well. Consequently, it is better to turn these
# neurons off. That can be done by setting their thresholds to values
# greater than 1.
#spike_thresholds = 0.99 0.97 0.90 0.90 0.95 0.95
spike_thresholds = 0.99 1.50 1.50 1.50 1.50 1.50

# As mentioned above, LGMD, FFI and DSMD spike counts are computed by
# scaling down their raw membrane potentials to a number in the range
# [.5,1]. The formula used to scale the raw membrane potentials down to
# the [.5,1] range is the following sigmoid function:
#
#                                       1
#                           u = -----------------
#                               1 + exp(-U/(n*N))
#
# where U is the raw membrane potential obtained by summing the relevant
# portion(s) of the S-layer; N is the total number of pixels in the
# locust's FOV; and n is a fudge factor as described below.
#
# The fudge factor magnifies the total visual area of our virtual
# locust. It doesn't necessarily make any real sense; it's really just a
# knob that seems to get things working a wee bit smoother when twiddled
# just right.
#
# As for the previous setting, this one too is a space-separated list of
# numbers. Again, the first element in the array is the fudge factor for
# the LGMD; the second one is for the FFI; and the remaining 4 are for
# the left, right, up and down DSMD neurons.
area_magnifiers = 2 5 500 500 500 500

# The feed-forward inhibition that attempts to suppress whole-field
# motion stimuli can be turned on or off with the following flag. The
# idea behind the FFI cell is that it measures excitation in the
# photoreceptive layer of the LGMD neural network model and shuts down
# LGMD spikes if P-layer excitation is large as this indicates
# ego-motion.
#
# NOTE: The FFI cell does not seem to work as described in papers by
# Stafford, Blanchard, etc. When it is turned on, it suppresses LGMD
# spikes even during collisional stimuli. In the Robolocust
# implementation, it is usually best to keep it off.
#ffi = on
ffi = off

# The directionally sensitive motion detectors that attempt to ascertain
# whether or not the LGMD is currently registering lateral motion can be
# turned on or off with the following flag.
#
# The DSMDs detect motion in the left, right, up and down directions.
# Large motion in one channel that is not mirrored in the opposing one
# would mean that the robot is currently executing a turn rather than
# actually approaching something head-on or being approached by
# something head-on. On the other hand, collisional motion would
# register as expansion in all the directionally sensitive neurons.
#
# NOTE: Like the FFI, the DSMDs do not quite work as described by
# Stafford, et al. They too result in suppressing collisional motion
# cues in addition to suppressing lateral motion. It seems to be best to
# keep them turned off for now (till we figure out how to fix the
# problem).
#dsmd = on
dsmd = off

# If the DSMDs are on, the following thresholds will be applied to check
# for horizontal and vertical lateral motions. Here's how these
# thresholds work: let us say that we want to check for horizontal
# lateral motion and its threshold is 10. Then, we will measure the
# membrane potentials of the left and right DSMDs and if one is greater
# than the other by a factor of 10, we conclude that there is lateral
# motion in the horizontal direction. Ditto for the vertical case.
#horizontal_motion_threshold = 1.5
#vertical_motion_threshold   = 2.5

# The DSMD potential is computed by using blocks of pixels in the
# S-layer that run across the center of the entire image along both
# axes. In their paper, Stafford et al. use 10x10 blocks. In our case,
# we try to do that too. However, if this size doesn't quite work out,
# we fall back to an alternative (smaller) size to be able to cover the
# entire image width and height while still getting at least 2-3 EMDs.
#
# NOTE: The default values specified here for these settings should work
# fine for Robolocust. But if the locust FOVs are very small, these
# settings may need tweaking.
ideal_dsmd_block_size = 10
alt_dsmd_block_size   = 4

# The final decision regarding whether or not to output a spike from the
# LGMD neural network can be made by combining the spikes in the LGMD,
# the FFI and DSMD neurons as a weighted sum. Thus, even if the LGMD
# itself does not have any spiking activity, it is still possible to
# emit a weakened spike by weighting the spikes in the FFI and DSMD and
# including them in the running average computation.
#
# The following setting specifies the weights for the spikes in the
# LGMD, FFI and DSMD. These weights should all be numbers between zero
# and one. Furthermore, all the six numbers should sum to unity.
#
# NOTE: This weighted sum spike computation is not described in any of
# the LGMD related papers by Stafford, Blanchard, Yue, Rind and gang. It
# is something the Robolocust author made up in an effort to try and get
# this LGMD model to work properly (i.e., suppress lateral motions and
# respond only to collisional stimuli).
#
# The weighted sum can be turned of by setting the spike weight for the
# LGMD neuron (the first number in the following list) to one and all
# the others to zero.
#
# As usual, the first number is for the LGMD; the second one for the
# FFI; and the remaining four for the left, right, up and down DSMDs
# respectively.
#
# NOTE 2: One useful thing these weights can be used for is to
# test/debug the DSMDs. For example, if we set the spike weight for the
# left DSMD (the third number) to 1 and all the others to 0, we can
# check to make sure that the left DSMD responds only to leftwards
# motion and not to any others. Ditto for the right, up and down DSMD
# weights.
#spike_weights = 0.4 0.0 0.2 0.2 0.1 0.1
spike_weights = 1 0 0 0 0 0

# The LGMD spike rate is computed as a running average of the spike
# count using the usual formula:
#       running average = w*current + (1-w)*old
#
# The following parameter specifies the value of w in the above formula.
# It should be a number between 0 and 1. Higher values indicate greater
# confidence in the current readings while lower ones give greater
# weight to older readings.
#
# For this model, the raw membrane potentials tend to be quite jumpy.
# So lower running average weights tend to do a better job of smoothing
# out the overall spike rate.
running_average_weight = 0.25

# These numbers specify the possible range of values the LGMD spike rate
# computed by this model can take on. The numbers are not specified in
# the Stafford paper, but are also not plucked out of thin air. Papers
# by Gabbiani, et al. and Guest and Gray present data gleaned from
# electrophysiological recordings of the LGMD. And they report peak
# firing rates of approximately 200 spikes per second very near
# time-to-collision. It would be best to set the range around these
# empirically obtained numbers. But really, these settings are quite
# arbitrary (as the spikes generated by our virtual locusts don't really
# have any physical meaning).
spike_range = 0 300

#------------------------ GABBIANI LOCUST MODEL -------------------------

# The settings in this section control various parameters that are used
# by the Gabbiani model, which is implemented in LoGabbiani.[CH] and a
# couple of other source files.
[gabbiani]

# Each virtual locust is setup to look along some particular direction.
# The following setting's value is expected to be a list of angles along
# which each locust should look. The number of entries in this list will
# specify the total number of virtual locusts created by the Robolocust
# application.
#
# Each direction is specified in degrees. Zero degrees corresponds to
# looking straight ahead; positive values are for directions on the left
# and negative angles for the right.
#
# To ensure that the visualization works properly, it would be best to
# specify this list starting at the left and moving to the right, i.e.,
# sorted in descending order.
locust_directions = 95 75 60 45 30 15 0 -15 -30 -45 -60 -75 -95

# The Gabbiani model can generate LGMD spikes using either the laser
# range finder and the robot's current velocity to determine
# time-to-impact or by using camera inputs and an optical flow algorithm
# to determine time-to-impact.
#
# In either case, each locust must be associated with some field of
# view. When using the laser range finder, the FOV will be the angular
# range about the main direction in which each virtual locust will
# consider distance readings. For camera input, the FOV specifies the
# width of each video frame (in pixels) the locust will consider when
# making spike rate calculations.
locust_fov = 30

# Various parameters for tweaking the Gabbiani model
# FIXME: Explain these things a little better!
C = 150
alpha = 0.75
delta = 2.5
l_over_v = 1.5

# These numbers specify the possible range of values the LGMD spike rate
# computed by the Gabbiani model can take on. Papers by Gabbiani, et al.
# and Guest and Gray present data gleaned from electrophysiological
# recordings of the LGMD. And they report peak firing rates of
# approximately 200 spikes per second very near time-to-collision. It
# would be best to set the range around these empirically obtained
# numbers.
#
# NOTE: Unlike the Stafford model, where the spike rate did not have any
# real physical meaning, these values do in fact indicate actual LGMD
# firing rates (or so we hope).
spike_range = 0 800

# To better simulate LGMD spikes generated by actual locusts, we can
# corrupt the "ideal" spikes generated by the Gabbiani model with some
# Gaussian noise. This parameter specifies the standard deviation to use
# for the spike noise.
sigma = 0

# Each locust model provides support for visualizing the LGMD spiking
# activity. However, this support must be turned on explicitly.
# Otherwise, nothing will be visualized.
visualization = on

# The location and size (inside the Robolocust main window) of this
# LGMD model's drawing area.
geometry = 0 75 975 75

#--------------------------------- UI -----------------------------------

# This section allows various tweaks to the Robolocust UI.
[ui]

# Do we even want to show the UI? When the robot is running on its own
# and doesn't have any available network connection, it would be best
# to just turn it off.
#show_ui = no

# This setting is used to specify a window title for the Robolocust UI. 
title = Robolocust

# The Robolocust UI supports taking screenshots of itself after each
# iteration of the render cycle and then saving these screenshots as
# JPEG or PNG files. By default, the screen capture functionality is
# off. This flag turns it on.
#screen_capture = on

# When screen capturing is turned on, Robolocust will write each frame
# to the directory specified by the following setting. A time-stamp
# corresponding to when the Robolocust application was launched will be
# automatically appended to this setting's value. The format of the
# time-stamp is "YYYYmmdd-HHMMSS". Thus, if the value of this setting is
# "/tmp/foo-" and the application was launched at midnight on January
# 1st, 2000, all frames will be written to "/tmp/foo-20000101-000000".
screen_capture_dir = /tmp/lobot-frames-

# Each frame saved by the screen capturing process will be named
# frame000.png, frame001.png, frame002.png, and so on. This setting
# specifies the number of digits in the numeric part of the frame name.
# The default is six digits. Thus, by default, frames will be named
# frame000000.png, frame000001.png, and so on.
screen_capture_len = 6

# Robolocust uses the OpenIL library (aka libdevil) to save frames to
# disk. Thus, it can write the individual frames in any of the file
# formats supported by OpenIL. This setting specifies the format to use
# for the individual screen capture frames. It should be a 3-letter
# string such "png", "jpg", "pnm", "tif", etc.
# 
# NOTE: Depending on how OpenIL is compiled and installed, some image
# file formats may not be supported. Generally, it is best to stick to
# the "png" or "jpg" formats. By default, Robolocust saves its frames as
# PNG files.
screen_capture_fmt = png

# This setting specifies the initial zoom level for drawables that
# support zoom/pan operations. Its value should be a floating point
# number. Here's how it works: a value of 1 (the default) will result in
# things being shown as-is. Fractional values zoom out the drawables,
# i.e., make it smaller; for example, a value of 0.5 would show the
# drawable in half-size. Values greater than unity zoom into the
# drawable, e.g., 2 would double the drawable's size.
initial_zoom = 1

# Middle-mouse button drags can be used to zoom in and out of the
# visualization. We can speed up or slow down the zoom by adjusting the
# following factor. Higher values will result in amplifying mouse motion
# so that even a small movement results in a large zoom in or out; lower
# values will damp the mouse motion so that more dragging is required to
# achieve the desired zoom level.
zoom_drag_factor = 0.1

# The Robolocust UI runs in its own thread. The following setting
# specifies the frequency with which this thread's updates should be
# performed. It is expected to be a time expressed in milliseconds.
# Thus, for some value N, the update will be performed once every N
# milliseconds.
update_frequency = 250

#---------------------- LASER VISUALIZER SETTINGS -----------------------

# When lobot is using the laser range finder as its primary input device
# rather than cameras, it sports a separate UI for help visualizing
# what's going on. This section specifies various settings related to
# this visualizer.
[laser_viz]

# A flag to indicate whether the LRF visualization should be turned
# on/off.
visualization = on

# The LRF visualizer's location and size within the Robolocust main
# window.
geometry = 0 0 480 480

# The LRF visualizer can draw the laser range finder's measurements as
# either rays emanating from the device or as a hull joining the end
# points of these rays (but without the rays themselves). The following
# setting determines which style will be used. Acceptable values are
# "rays" or "hull" (without the double quotes). The default is to render
# the measurements as rays.
measurements_style = hull

# The LRF returns distance measurements corresponding to a range of
# angles with zero degrees being in front of the device, negative angles
# on the right and positive angles on the left.  Drawing the
# measurements for all the angles in the device's range can result in a
# very cluttered and illegible picture. This setting specifies the range
# of angles to use and the step size by which to increment the angle as
# we iterate through this range.
angles_range = -135 135
angles_step  = 5

# The color in which to render the distance measurements made by the
# laser range finder.
measurements_color = 0 192 192

# In the visualization window, the laser range finder is depicted as a
# combination of a rectangle and a triangle. If this figure were drawn
# with the triangle pointed upward, it would have the shape of a house.
# However, it is not necessary that the LRF be drawn pointing up. The
# following two settings specify the size and direction of the LRF.
# 
# The direction is simply an angle in the range 0 to 360 degrees with
# zero degrees corresponding to the positive x-axis and angles going
# counter-clockwise. Negative (i.e. clockwise) angles are also allowed.
# 
# The dimensions of the LRF representation are specified in terms of the
# half-size of the shared edge between the rectangle and triangle. If
# this size is R, then the entire figure will be inscribed within an
# imaginary square of size 2R.
# 
# NOTE: As the visualization window's logical/world coordinate system is
# setup to match the Hokuyo's specs, the units of the above-mentioned R
# will be millimeters. However, these are "logical" not true physical
# mm.
lrf_size = 50
#lrf_direction = -90

# This setting specifies the color for the rectangle + triangle used to
# represent the laser range finder within the visualization window.
lrf_color = 255 48 48

# This section is also used for the laser visualizer. Because of some
# arcane design and implementation issues, these settings cannot be
# rolled into the [laser_viz] section above.
#
# These settings allow users to tweak various aspects of the regular
# markings used to help make it easier to read the distance measurements
# being returned by the laser range finder.
[markings]

# The laser range finder's distance measurements are depicted as rays
# emanating from the device (which is shown as a small upward pointing
# triangle). To make it easier to read the values of these distances,
# the laser visualizer puts markers at regular intervals.
#
# This setting specifies the kind of markers we want.
type = rings
#type = grid

# This setting specifies the intervals at which the markings should be
# placed. Since the Hokuyo laser range finder returns distances in
# millimeters, these intervals are also specified in mm.
intervals = 100 500 1000 5000

# For each of the above intervals, we specify a corresponding color and
# zoom range. The markers for that interval will be drawn in the
# specified color and will only be visible at zoom levels lying in the
# given range.
color_100 = 48 48 48
zoom_100  = 7.5 1000

color_500 = 96 96 96
zoom_500  = 5 1000

color_1000 = 128 128 0
zoom_1000  = 3 1000

color_5000 = 128 0 0
zoom_5000  = 0.05 1000

# In addition to the interval markings, we can also choose to draw the
# main axes. The following setting specifies the color in which the main
# axes should be drawn. If this setting is not explicitly configured,
# the main axes will not be drawn.
main_axes_color = 255 255 255

# LRF data can be visualized in its usual polar form as well as in a
# "flattened" form. This section specifies various settings related to
# this form of LRF data visualization.
[laser_viz_flat]

# A flag to indicate whether the flat LRF visualization should be turned
# on/off.
visualization = on

# The flat visualizer's location and size within the Robolocust main
# window.
geometry = 0 480 480 80

#---------------------- LOCUST VISUALIZER SETTINGS ----------------------

# When lobot is avoiding obstacles using its locust model and LGMD-based
# avoidance algorithms, it can show the spike rates being generated for
# each of the locusts. This section specifies various settings related
# to this spike rate visualizer.
[locust_viz]

# The spike rate visualizer shows each LGMD's current value as a bar
# starting at the center of the visualizer window and going out along
# the direction vector of that LGMD. The length of this bar denotes
# magnitude of the spiking activity for the locust looking in the bar's
# direction.
# 
# Thus, for the entire array of locusts, the visualizer will resemble
# the depiction of a range sensor such as the laser range finder with
# the individual "rays" denoting the "range" measurement (in this case
# spike rate) along each of the directions "scanned" by this sensor.
# 
# This setting specifies the width (in pixels) of the spike rate
# rays/bars.
ray_width = 3

# This setting specifies the color of the LGMD "range sensor" rays. It
# should be a triple of integers, each in the range [0,255].
ray_color = 255 0 0

# To help gauge each ray's associated numeric value, we draw a series of
# concentric rings. This setting specifies the increments in the radii
# between two consecutive rings. Its unit is Hertz. Its value should be
# a reasonable number between the min and max spike rate range specified
# for the locust model in effect.
# 
# For example, if the spike range is 0 to 800 and this increment is
# given as 100, the visualizer will setup its internal coordinate system
# to go from 0 to 800 in each direction and draw 8 circles, starting
# with a radius of 100 units and incrementing thereafter by 100 units
# all the way up to 800. By seeing where each ray's end point falls, the
# user can get a rough idea of the spike rate associated with that ray.
ring_incr = 100

# This setting specifies the color of concentric rings described above.
# It should be a triple of integers, each in the range [0,255].
ring_color = 96 96 96

# A flag to indicate whether the locust spike rate visualization should
# be turned on/off.
visualization = on

# The spike rate visualizer's location and size within the Robolocust
# main window.
geometry = 0 0 480 480
