/*!@file AppNeuro/getSubMapData.C program get eye tracking data and compute NSS  */

// //////////////////////////////////////////////////////////////////// //
// The iLab Neuromorphic Vision C++ Toolkit - Copyright (C) 2000-2005   //
// by the University of Southern California (USC) and the iLab at USC.  //
// See http://iLab.usc.edu for information about this project.          //
// //////////////////////////////////////////////////////////////////// //
// Major portions of the iLab Neuromorphic Vision Toolkit are protected //
// under the U.S. patent ``Computation of Intrinsic Perceptual Saliency //
// in Visual Environments, and Applications'' by Christof Koch and      //
// Laurent Itti, California Institute of Technology, 2001 (patent       //
// pending; application number 09/912,225 filed July 23, 2001; see      //
// http://pair.uspto.gov/cgi-bin/final/home.pl for current status).     //
// //////////////////////////////////////////////////////////////////// //
// This file is part of the iLab Neuromorphic Vision C++ Toolkit.       //
//                                                                      //
// The iLab Neuromorphic Vision C++ Toolkit is free software; you can   //
// redistribute it and/or modify it under the terms of the GNU General  //
// Public License as published by the Free Software Foundation; either  //
// version 2 of the License, or (at your option) any later version.     //
//                                                                      //
// The iLab Neuromorphic Vision C++ Toolkit is distributed in the hope  //
// that it will be useful, but WITHOUT ANY WARRANTY; without even the   //
// implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      //
// PURPOSE.  See the GNU General Public License for more details.       //
//                                                                      //
// You should have received a copy of the GNU General Public License    //
// along with the iLab Neuromorphic Vision C++ Toolkit; if not, write   //
// to the Free Software Foundation, Inc., 59 Temple Place, Suite 330,   //
// Boston, MA 02111-1307 USA.                                           //
// //////////////////////////////////////////////////////////////////// //
//
// Primary maintainer for this file: Farhan Baluch <fbaluch at usc dot edu>
// $HeadURL: svn://isvn.usc.edu/software/invt/trunk/saliency/src/AppNeuro/getSubMapData.C $
// $Id: getSubMapData.C 10794 2009-02-08 06:21:09Z itti $
//

#ifndef APPNEURO_GETSUBMAPDATA_C_DEFINED
#define APPNEURO_GETSUBMAPDATA_C_DEFINED

#include "Component/ModelManager.H"
#include "Image/Image.H"
#include "Image/Pixels.H"
#include "Image/ShapeOps.H" // for rescale()
#include "Neuro/getSaliency.H"
#include "Raster/Raster.H"
#include "Util/log.H"
#include "Psycho/EyeTrace.H"
#include "Image/MathOps.H"
#include <fstream>
#include <iostream>
//this code will take as input an image file and an eye file and computes NSS for all submaps generated by the model for the image.

float getNSS(const std::vector<Point2D<int> >& sacTargs, Image<float> salMap);


float getNSS(const std::vector<Point2D<int> >& sacTargs, Image<float> salMap)
{

        //first normalize salmap
    double m,s;

    m = mean(salMap);
    s = stdev(salMap);
    std::vector<double> NSS(sacTargs.size());
    double NSStotal=0.0;
    int Ncnt=0;
    float tempX,tempY;
    LINFO("\n saccade target size %d",(int)sacTargs.size());

    if (s > 0)
    {
        for(size_t cnt=0; cnt < sacTargs.size(); cnt++)
        {
            tempX = (sacTargs[cnt].i)/16;
            tempY = (sacTargs[cnt].j)/16;

            if(salMap.coordsOk(tempX,tempY))
            {   LINFO("%d ,hello  x%f y:%f", (int)cnt,tempX,tempY);
                //LINFO("%f",salMap.getVal(tempX,tempY));
                NSS[Ncnt] = (salMap.getVal((int)tempX,(int)tempY) - m) / s;
                Ncnt++;
            }
        }
    }

    for (size_t i =0; i < NSS.size(); i++)
             {
                 NSStotal += NSS[i];
                 LINFO("NSS[%d] %f",(int)i,NSS[i]);
             }

    if(Ncnt > 1)
        NSStotal =  NSStotal/(Ncnt-1);

    return NSStotal;

//computeNSS

}



int main(int argc, char** argv)
{
  ModelManager manager("test");

  nub::ref<GetSaliency> saliency(new GetSaliency(manager));
  manager.addSubComponent(saliency);
  if (manager.parseCommandLine(argc, argv, "<input-image><eye-file><save-file>", 3, 3) == false)
    return -1;
  manager.start();


  std::string imgFile, eyeFile,saveFile;
  imgFile =  manager.getExtraArg(0);
  eyeFile =  manager.getExtraArg(1);
  saveFile = manager.getExtraArg(2);


  const Image<PixRGB<byte> > img = Raster::ReadRGB(imgFile);
  const int num_salient_spots = saliency->compute(img, SimTime::SECS(0.1));
  LINFO("found %d salient spots", num_salient_spots);
  const Image<float> salmap = saliency->getSalmap();
  const Image<float> resized_salmap = rescale(salmap, img.getDims());
  const std::vector<subMap> itsSubMaps = saliency->getSubMaps();


   rutz::shared_ptr<EyeTrace> et(new EyeTrace(eyeFile, PixRGB<byte>(255)));
   rutz::shared_ptr<EyeData> data;
   std::vector<Point2D<int> > sacTargets(et->numSaccades());
   LINFO("the num sac %d",(int)et->numSaccades());


       /* char filename[256];
   sprintf(filename, "%s",(char*)imgFile);
       // filename = imgFile;

       // FILE* outputFile = fopen(filename, "w+");
       // if(outputFile==0)
       //LFATAL("couldnt open file:%s", filename);
       */

   std::ofstream outputFile;
   outputFile.open(saveFile.c_str());

   size_t index=0;
   int cnt =0;

   while(et->hasData(index))      //lets load the saccade targets and store them in a vec
   {
      data = et->data(index);
      if(data->hasSaccadeTargetData())
         {
             sacTargets[cnt] = data->saccadeTarget();
             LINFO("sacctarget %d  %d,%d",cnt,sacTargets[cnt].i,sacTargets[cnt].j);
             cnt++;
         }

       index++;

   }

   getNSS(sacTargets,itsSubMaps[0].itsSubMap);

   float temp;
   for(int i =0; i < (int)itsSubMaps.size(); i++)
   {
           //    fprintf(outputFile,"%f\n",getNSS(sacTargets, itsSubMaps[i]));
       temp = getNSS(sacTargets, itsSubMaps[i].itsSubMap);
       outputFile << temp <<"\n";
    }


  Raster::WriteFloat(resized_salmap, FLOAT_NORM_0_255, "salmap.png");
  Raster::WriteFloat(rescale(itsSubMaps[1].itsSubMap,
                             img.getDims()), FLOAT_NORM_0_255,"subMap1.png");

  outputFile.close();
  manager.stop();

  return 0;
}

// ######################################################################
/* So things look consistent in everyone's emacs... */
/* Local Variables: */
/* mode: c++ */
/* indent-tabs-mode: nil */
/* End: */

#endif // APPNEURO_GETSUBMAPDATA_C_DEFINED
